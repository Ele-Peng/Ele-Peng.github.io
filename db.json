{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/hexo-theme-lx/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/css/main.min.css","path":"css/main.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/images/footer-l.jpeg","path":"images/footer-l.jpeg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/js/jquery.easing.min.js","path":"js/jquery.easing.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/js/jquery.jside.menu.js","path":"js/jquery.jside.menu.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/images/footer-r.jpeg","path":"images/footer-r.jpeg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/images/post_cover.jpeg","path":"images/post_cover.jpeg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/js/local.search.js","path":"js/local.search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/css/menu/button.styl","path":"css/menu/button.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/css/page_style/page_style.styl","path":"css/page_style/page_style.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/css/menu/menu.styl","path":"css/menu/menu.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-lx/source/images/cover.jpeg","path":"images/cover.jpeg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-lx/.editorconfig","hash":"f8102695960fe708149c2e21934969700bfb0031","modified":1586055390182},{"_id":"themes/hexo-theme-lx/CODE_OF_CONDUCT.md","hash":"4faa826cb7049aff196edbf38e0b29c3fec2cf17","modified":1586055390183},{"_id":"themes/hexo-theme-lx/CONTRIBUTING.md","hash":"c70e994eb59d431ccaaf8b114ad74c8962cc3f45","modified":1586055390183},{"_id":"themes/hexo-theme-lx/LICENSE","hash":"2e43fe50cb85afda5cbd30aa4c056125f0e11a53","modified":1586055390184},{"_id":"themes/hexo-theme-lx/_config.yml","hash":"bed3cb1ac4c045d8bd4a87693eff773a5e71b1e6","modified":1586058314370},{"_id":"themes/hexo-theme-lx/package.json","hash":"7c15e6d012eee8b69d625b26f61adfd018a15f7f","modified":1586055390190},{"_id":"source/_posts/Elle-训练算法计划.md","hash":"577efe53bd6ec89d1bd736cac6cc1659eb269b04","modified":1586179068931},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1586058964847},{"_id":"source/_posts/OOP-面向对象.md","hash":"8353cfb56d6349f8d1e191e243330ba7d98e3ce3","modified":1586601844927},{"_id":"source/_posts/数组、链表、跳表.md","hash":"75a33cdce8e1c4cc1b6cbda72dd90ddd7cca1ad2","modified":1586395435490},{"_id":"source/_posts/自己的前端知识体系.md","hash":"ac378bf10ee2af5a27352a632d610b70c2c11e10","modified":1586703499562},{"_id":"source/_posts/微信小程序-fix canvas原生组件最顶层.md","hash":"7594e45db6b3f4965ffda6c57106e264cee8c722","modified":1586152068882},{"_id":"source/_posts/微信小程序-气泡框 Popover.md","hash":"56fde0206b0e6e0036a4c4247c6028f1fa506363","modified":1586152102773},{"_id":"source/_posts/微信小程序-获取图片主色调.md","hash":"45cfb5080b28c4d8f597e731820a38cbcf1bc3d9","modified":1586153959195},{"_id":"themes/hexo-theme-lx/languages/en.yml","hash":"ec59da08e7c8dc61872b7896f167e42491965b2e","modified":1586055390185},{"_id":"themes/hexo-theme-lx/languages/zh.yml","hash":"b9a174e46bd89df7d6bf3a7863c350a62dce8a81","modified":1586055390185},{"_id":"themes/hexo-theme-lx/layout/archive.ejs","hash":"539ad764457af4434a6764c2044c4bbb9c34759f","modified":1586055390185},{"_id":"themes/hexo-theme-lx/layout/index.ejs","hash":"6c73bb34c29861124a0464a9a8dea95adf4fc5b0","modified":1586055390185},{"_id":"themes/hexo-theme-lx/layout/layout.ejs","hash":"a8e012724633a45c7601c38866176e11f88b0db9","modified":1586055390186},{"_id":"themes/hexo-theme-lx/layout/page.ejs","hash":"c0895bd2b63c5bba7c54686d6b7eaec9fbc520a5","modified":1586055390186},{"_id":"themes/hexo-theme-lx/layout/post.ejs","hash":"9396418ae3822ee444f44c509ec27955842c9360","modified":1586055390189},{"_id":"themes/hexo-theme-lx/source/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1586055390194},{"_id":"themes/hexo-theme-lx/layout/partials/aside.ejs","hash":"e9ea462c34f4edba0c62c5478b4a96edb66769ef","modified":1586055390186},{"_id":"themes/hexo-theme-lx/layout/partials/config.ejs","hash":"6809577629e67dc00a2b20c2326818fa7f2c29be","modified":1586055390186},{"_id":"themes/hexo-theme-lx/layout/partials/font.ejs","hash":"2dc65c0b4f60ed8329a296c5172aee8d42025a1e","modified":1586055390186},{"_id":"themes/hexo-theme-lx/layout/partials/footer.ejs","hash":"079fcedbca1fc74485d82510354a00a39f52b0e9","modified":1586246253990},{"_id":"themes/hexo-theme-lx/layout/partials/menu.ejs","hash":"7c3d71999f233f5fb7549a472c922c8257711d5f","modified":1586055390187},{"_id":"themes/hexo-theme-lx/layout/partials/pagination.ejs","hash":"82c25643c1e3b16f0472eebfe77f4a03ad0e8824","modified":1586055390187},{"_id":"themes/hexo-theme-lx/layout/partials/post-footer.ejs","hash":"a2dbce8103bdc694439e8709c7f636f68ccc3328","modified":1586055390187},{"_id":"themes/hexo-theme-lx/layout/partials/post-header.ejs","hash":"adc798cf72c82a069fb354f48f65bba5f1405b45","modified":1586055390188},{"_id":"themes/hexo-theme-lx/layout/partials/recent-posts.ejs","hash":"889018a6df0c62b61c1c03712a2d3eb39882559c","modified":1586055390188},{"_id":"themes/hexo-theme-lx/layout/partials/search.ejs","hash":"e68af7bfc83edcf8da639982e1766c53f129128f","modified":1586055390188},{"_id":"themes/hexo-theme-lx/layout/partials/sociallinks.ejs","hash":"4460e06f88084f545b4409685644c7f101d11ba5","modified":1586055390188},{"_id":"themes/hexo-theme-lx/layout/third-party/comment.ejs","hash":"f1d1c9425059e76c8481829797de44df637c0723","modified":1586055390190},{"_id":"themes/hexo-theme-lx/layout/third-party/mathjax.ejs","hash":"e857f83195594e6ffcacf08f07df0c229806113b","modified":1586055390190},{"_id":"themes/hexo-theme-lx/scripts/helpers/font.js","hash":"0e7adebaf7bb3ba516c8f82cf26100237584bf44","modified":1586055390191},{"_id":"themes/hexo-theme-lx/scripts/tags/button.js","hash":"dd5da28768a3ed3f2e3b308a9ff220403825579f","modified":1586055390191},{"_id":"themes/hexo-theme-lx/scripts/tags/center-quote.js","hash":"e5086a9b99ac1c8006f4fa7c5568b96cc1d47cf6","modified":1586055390191},{"_id":"themes/hexo-theme-lx/scripts/tags/label.js","hash":"7247ac0f614993d4d162b14b68e924fc969581f5","modified":1586055390191},{"_id":"themes/hexo-theme-lx/scripts/tags/note.js","hash":"19dc88f867d684101e851e25fe9da661c56acc66","modified":1586055390192},{"_id":"themes/hexo-theme-lx/scripts/tags/video.js","hash":"3a70f28b9769fd308c8df7d694fb7f896f12ae58","modified":1586055390192},{"_id":"themes/hexo-theme-lx/source/css/base.styl","hash":"f29e3f7ab355d599d186ffc4a457169df4af3ad5","modified":1586055390192},{"_id":"themes/hexo-theme-lx/source/css/main.min.css","hash":"f92bf3eef5351215ee8bced4a40d88dab68330bf","modified":1586055390193},{"_id":"themes/hexo-theme-lx/source/css/main.styl","hash":"270db895d246e6084cb7a1a2620ded803313624b","modified":1586055390193},{"_id":"themes/hexo-theme-lx/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1586058157729},{"_id":"themes/hexo-theme-lx/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1586055390200},{"_id":"themes/hexo-theme-lx/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1586055390200},{"_id":"themes/hexo-theme-lx/source/images/footer-l.jpeg","hash":"f036edc5f66ffbcc34c3d855414c6ca5ef30a04b","modified":1586055390198},{"_id":"themes/hexo-theme-lx/source/js/jquery.easing.min.js","hash":"af83a43279779fbc716f40ba8c5280782027540a","modified":1586055390200},{"_id":"themes/hexo-theme-lx/source/js/jquery.jside.menu.js","hash":"d15b40199520d22771f9a211ac4282041df2ae5a","modified":1586055390200},{"_id":"themes/hexo-theme-lx/source/images/footer-r.jpeg","hash":"5c7677ac85cf8a683b91e97702b7096017006b4f","modified":1586055390198},{"_id":"themes/hexo-theme-lx/source/images/post_cover.jpeg","hash":"93f216636c87dbbe635d4bb6b944851d92d84723","modified":1586055390199},{"_id":"themes/hexo-theme-lx/source/js/local.search.js","hash":"3dd788d1e64431feb8faca7a7f175d25ed31f25a","modified":1586055390201},{"_id":"themes/hexo-theme-lx/layout/third-party/analytics/baidu-analytics.ejs","hash":"30cf8cd193777b1e071313528e06b16eca508187","modified":1586055390189},{"_id":"themes/hexo-theme-lx/layout/third-party/analytics/google-analytics.ejs","hash":"09775c366a01c656b7185ef3da4bc7b33caa2241","modified":1586055390189},{"_id":"themes/hexo-theme-lx/layout/third-party/analytics/index.ejs","hash":"c98b574b2634de33694edb40b1f9120160b81acb","modified":1586055390189},{"_id":"themes/hexo-theme-lx/source/css/menu/button.styl","hash":"d440d99e13b0f58edcab27bfce4e027e0e54fd77","modified":1586055390193},{"_id":"themes/hexo-theme-lx/source/css/page_style/page_style.styl","hash":"d10cea4992ee10e2ab88a2ae0ebe08854f55d7c6","modified":1586055390194},{"_id":"themes/hexo-theme-lx/source/css/menu/menu.styl","hash":"ebe4d6bc7e0081ad4d7659427abb98a1344c1aae","modified":1586055390194},{"_id":"themes/hexo-theme-lx/source/images/avatar.jpeg","hash":"b6aba9aa030f22221d4a357a46a6bc6ef0cce556","modified":1586058121609},{"_id":"themes/hexo-theme-lx/source/images/cover.jpeg","hash":"13c52245fa1cede0083970f0facefa98017d48bc","modified":1586057417206},{"_id":"public/search.xml","hash":"7de1599e27d5b541dc4e0851626ee48f87de8feb","modified":1586703535658},{"_id":"public/2020/04/12/自己的前端知识体系/index.html","hash":"c393e174ef54fef9211759ac202310bb587e527a","modified":1586703535658},{"_id":"public/2020/04/07/数组、链表、跳表/index.html","hash":"e9c10f1439bf20bd0c69c897eac125bb7be69db5","modified":1586703535658},{"_id":"public/2020/04/06/Elle-训练算法计划/index.html","hash":"518128939f91475857845efb31a0d1cfccfddb44","modified":1586703535658},{"_id":"public/categories/算法/index.html","hash":"78c791790aacd2828391a4f89f1dfd98019b3787","modified":1586703535658},{"_id":"public/categories/前端概念/index.html","hash":"e7bd2ceacc3346eb9751953c392f646236fd073c","modified":1586703535658},{"_id":"public/categories/微信小程序/index.html","hash":"99424075282c743710e688e64303efb181a73474","modified":1586703535658},{"_id":"public/index.html","hash":"7d65faa4944c90df02da77359347b2d95ade3c38","modified":1586703535658},{"_id":"public/archives/index.html","hash":"578468998a867423ea531e7b4ad5f07b3cf8f6e5","modified":1586703535658},{"_id":"public/archives/2020/index.html","hash":"578468998a867423ea531e7b4ad5f07b3cf8f6e5","modified":1586703535658},{"_id":"public/archives/2020/04/index.html","hash":"578468998a867423ea531e7b4ad5f07b3cf8f6e5","modified":1586703535658},{"_id":"public/tags/算法/index.html","hash":"2e5daf0c6267195d65c48f5bdd23b5987fadaa52","modified":1586703535658},{"_id":"public/tags/前端概念/index.html","hash":"6cd9330f5f3eb63eb2ad22870ffc87da1b81c820","modified":1586703535658},{"_id":"public/tags/微信小程序/index.html","hash":"2b6aecdb249e4551566ce5dce0bfbca313b5af43","modified":1586703535658},{"_id":"public/2020/04/09/OOP-面向对象/index.html","hash":"7caecddd6179ff0633d3be8820489891a4d65a41","modified":1586703535658},{"_id":"public/2020/04/05/微信小程序-获取图片主色调/index.html","hash":"2f292a698fbd998f653ebc3ecde6b77cf93d35e1","modified":1586703535658},{"_id":"public/2020/04/05/微信小程序-fix canvas原生组件最顶层/index.html","hash":"91f3f9f1b43c6f74ebbd55b440a6d9b33d280d65","modified":1586703535658},{"_id":"public/2020/04/05/微信小程序-气泡框 Popover/index.html","hash":"e3133c4fed885393c9c170e5dbe426dd203c644a","modified":1586703535658},{"_id":"public/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1586703535658},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1586703535658},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1586703535658},{"_id":"public/images/footer-l.jpeg","hash":"f036edc5f66ffbcc34c3d855414c6ca5ef30a04b","modified":1586703535658},{"_id":"public/images/footer-r.jpeg","hash":"5c7677ac85cf8a683b91e97702b7096017006b4f","modified":1586703535658},{"_id":"public/images/post_cover.jpeg","hash":"93f216636c87dbbe635d4bb6b944851d92d84723","modified":1586703535658},{"_id":"public/css/base.css","hash":"6d884ebc4f4c1a7c750e4b871ecfff6c28b47ed0","modified":1586703535658},{"_id":"public/js/jquery.jside.menu.js","hash":"688b8b03f8590a05e35a1fbbc59f37bc36051aa1","modified":1586703535658},{"_id":"public/js/jquery.easing.min.js","hash":"af83a43279779fbc716f40ba8c5280782027540a","modified":1586703535658},{"_id":"public/css/menu/button.css","hash":"ce03713a291978281b66ce9d5738c456020a8e61","modified":1586703535658},{"_id":"public/css/page_style/page_style.css","hash":"0488c30dc3e728ec5ec89bb49fe979bd84acc964","modified":1586703535658},{"_id":"public/css/menu/menu.css","hash":"70f8a5b346f4b106eebc1c5199bc4add479da3c5","modified":1586703535658},{"_id":"public/js/local.search.js","hash":"3dd788d1e64431feb8faca7a7f175d25ed31f25a","modified":1586703535658},{"_id":"public/css/main.css","hash":"0235a5e568abff3de00c0228a94f47fd4f754575","modified":1586703535658},{"_id":"public/css/main.min.css","hash":"f92bf3eef5351215ee8bced4a40d88dab68330bf","modified":1586703535658},{"_id":"public/images/avatar.jpeg","hash":"b6aba9aa030f22221d4a357a46a6bc6ef0cce556","modified":1586703535658},{"_id":"public/images/cover.jpeg","hash":"13c52245fa1cede0083970f0facefa98017d48bc","modified":1586703535658}],"Category":[{"name":"算法","_id":"ck8x6bfzu0003zsp34f7ib86x"},{"name":"前端概念","_id":"ck8x6bfzy0006zsp360ic6hjh"},{"name":"微信小程序","_id":"ck8x6bfzz000azsp33sz4c38x"}],"Data":[],"Page":[],"Post":[{"title":"数组、链表、跳表","date":"2020-04-07T08:18:49.000Z","_content":"\n### 跳表\n- 补足链表linked list，look up O(n) 的缺陷，升维思想，以空间换时间\n- 数学归纳法\n- 找最近重复问题","source":"_posts/数组、链表、跳表.md","raw":"---\ntitle: 数组、链表、跳表\ndate: 2020-04-07 16:18:49\ntags:\n\n\n---\n\n### 跳表\n- 补足链表linked list，look up O(n) 的缺陷，升维思想，以空间换时间\n- 数学归纳法\n- 找最近重复问题","slug":"数组、链表、跳表","published":1,"updated":"2020-04-09T01:23:55.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8x6bfzj0000zsp38odl9buj","content":"<h3 id=\"跳表\"><a href=\"#跳表\" class=\"headerlink\" title=\"跳表\"></a>跳表</h3><ul>\n<li>补足链表linked list，look up O(n) 的缺陷，升维思想，以空间换时间</li>\n<li>数学归纳法</li>\n<li>找最近重复问题</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"跳表\"><a href=\"#跳表\" class=\"headerlink\" title=\"跳表\"></a>跳表</h3><ul>\n<li>补足链表linked list，look up O(n) 的缺陷，升维思想，以空间换时间</li>\n<li>数学归纳法</li>\n<li>找最近重复问题</li>\n</ul>\n"},{"title":"Elle-训练算法计划","date":"2020-04-06T10:37:00.000Z","description":["简单记录一下自己整个算法训练的基础步骤+学习方法"],"_content":"#### 写在前面\n- 简单记录一下自己整个算法训练的基础步骤+学习方法\n- 主要的数据结构和算法会单开文档来写\n\n<!-- more -->\n#### Chunk it up 切碎知识点\n- 数据结构\n\t- 一维数据结构\n\t\t- 基础：数组 array(string), 链表 linked list\n\t\t- 高级：栈 stack, 队列 queue, 双端队列 deque, 集合 set, 映射 map (hash or map), etc\n\t- 二维数据结构\n\t\t- 一维泛化\n\t\t- 基础：树 tree，图 graph\n\t\t- 高级：二叉搜索树 binary search tree (red-black tree, AVL)，堆 heap, 并查集 disjoint set, 字典树 trie, etc\n\t- 特殊数据结构\n\t\t-  位运算 bitwise, 布隆过滤器 bloom filter\n\t\t-  LRU Cache\n- 算法\n\t- if-else, switch --> branch\n\t- for, while loop --> iteration\n\t- 递归 recursion (divide & conquer 分治, backtrace 回溯)\n\t- 搜索 search: 深度优先搜索 depth first search, 广度优先搜索 breadth first search, A* (启发式搜索), etc\n\t- 动态规划 dynamic programing\n\t- 二分查找 binary search\n\t- 贪心 greedy\n\t- 数学 math, 集合 geometry\n\n#### Deliberate Practicing 刻意练习\n- 刻意练习-过遍数 (五遍刷题法)\n\t- 刷题第一遍\n\t\t- 5分钟（5~15 mins）：读题+思考\n\t\t- 直接看解法：注意！多解法，比较解乏优劣\n\t\t- 有思路，直接写\n\t\t- 背诵+默写好的解法\n\t- 刷题第二遍\n\t\t- 马上自己写 --> LeetCode提交\n\t\t- 多种解法比较、体会 --> 优化\n\t\t- 多种解法自己写一遍，直到通过\n\t- 刷题第三遍\n\t\t- 24h后，再重复做题\n\t\t- 不同解法的熟练程度 --> 专项练习\n\t- 刷题第四遍\n\t\t- 过了一周后：反复回来练习相同的题目\n\t\t- 不熟练的题目 --> 专项练习\n\t- 刷题第五遍\n\t\t- 面试前二周恢复性训练\n- 练习缺陷、弱点地方\n\t- 中文站 leetcode-cn.com 刷题\n\t- 国际站 leetcode.com 看discuss-most votes\n- 切题\n\t- **Clarification 审题**\n\t- **Possible Solutions**\n\t\t- compare (time/space)\n\t\t- optimal (加强)\n\t- **Coding**\n\t- **Test cases**\n\n#### Feedback 反馈\n- 即时反馈\n- 主动型反馈\n- 被动型反馈\n\t- code review\n\n#### 指法\n- top tips for vscode\n\n#### 自顶向下的编程方式\n- [自顶向下的编程方式](http://markhneedham.com/blog/2008/09/15/clean-code-book-review/)\n\n#### Big O Notation\n- O(1): constant Complexity 常数复杂度\n- O(log n): Logarithmic Complexity 对数复杂度\n- O(n): Linear Complexity 线性时间复杂度\n- O(n^2): N square Complexity 平方\n- O(n^3): N cube Complexity 立方\n- O(2^n): Exponential Growth 指数\n- O(n!): Factorial 阶乘\n- ![时间复杂度](http://p0.meituan.net/myvideodistribute/c88294c6a8b88448ae14e2914c7bbfd2337181.png)\n\n#### master theorem\n- 二分查找\n- 二叉树的遍历（每个节点都访问一次，且仅访问一次）\n- 二维有序矩阵\n- 归并排序 O(nlogn)\n- ![主定理](http://p1.meituan.net/myvideodistribute/5b978d58635ea2e9233ea5e502ab706f246540.png)","source":"_posts/Elle-训练算法计划.md","raw":"---\ntitle: Elle-训练算法计划\ndate: 2020-04-06 18:37:00\ntags: \n- 算法\ncategories:\n- 算法\ndescription:\n- 简单记录一下自己整个算法训练的基础步骤+学习方法\n\n\n---\n#### 写在前面\n- 简单记录一下自己整个算法训练的基础步骤+学习方法\n- 主要的数据结构和算法会单开文档来写\n\n<!-- more -->\n#### Chunk it up 切碎知识点\n- 数据结构\n\t- 一维数据结构\n\t\t- 基础：数组 array(string), 链表 linked list\n\t\t- 高级：栈 stack, 队列 queue, 双端队列 deque, 集合 set, 映射 map (hash or map), etc\n\t- 二维数据结构\n\t\t- 一维泛化\n\t\t- 基础：树 tree，图 graph\n\t\t- 高级：二叉搜索树 binary search tree (red-black tree, AVL)，堆 heap, 并查集 disjoint set, 字典树 trie, etc\n\t- 特殊数据结构\n\t\t-  位运算 bitwise, 布隆过滤器 bloom filter\n\t\t-  LRU Cache\n- 算法\n\t- if-else, switch --> branch\n\t- for, while loop --> iteration\n\t- 递归 recursion (divide & conquer 分治, backtrace 回溯)\n\t- 搜索 search: 深度优先搜索 depth first search, 广度优先搜索 breadth first search, A* (启发式搜索), etc\n\t- 动态规划 dynamic programing\n\t- 二分查找 binary search\n\t- 贪心 greedy\n\t- 数学 math, 集合 geometry\n\n#### Deliberate Practicing 刻意练习\n- 刻意练习-过遍数 (五遍刷题法)\n\t- 刷题第一遍\n\t\t- 5分钟（5~15 mins）：读题+思考\n\t\t- 直接看解法：注意！多解法，比较解乏优劣\n\t\t- 有思路，直接写\n\t\t- 背诵+默写好的解法\n\t- 刷题第二遍\n\t\t- 马上自己写 --> LeetCode提交\n\t\t- 多种解法比较、体会 --> 优化\n\t\t- 多种解法自己写一遍，直到通过\n\t- 刷题第三遍\n\t\t- 24h后，再重复做题\n\t\t- 不同解法的熟练程度 --> 专项练习\n\t- 刷题第四遍\n\t\t- 过了一周后：反复回来练习相同的题目\n\t\t- 不熟练的题目 --> 专项练习\n\t- 刷题第五遍\n\t\t- 面试前二周恢复性训练\n- 练习缺陷、弱点地方\n\t- 中文站 leetcode-cn.com 刷题\n\t- 国际站 leetcode.com 看discuss-most votes\n- 切题\n\t- **Clarification 审题**\n\t- **Possible Solutions**\n\t\t- compare (time/space)\n\t\t- optimal (加强)\n\t- **Coding**\n\t- **Test cases**\n\n#### Feedback 反馈\n- 即时反馈\n- 主动型反馈\n- 被动型反馈\n\t- code review\n\n#### 指法\n- top tips for vscode\n\n#### 自顶向下的编程方式\n- [自顶向下的编程方式](http://markhneedham.com/blog/2008/09/15/clean-code-book-review/)\n\n#### Big O Notation\n- O(1): constant Complexity 常数复杂度\n- O(log n): Logarithmic Complexity 对数复杂度\n- O(n): Linear Complexity 线性时间复杂度\n- O(n^2): N square Complexity 平方\n- O(n^3): N cube Complexity 立方\n- O(2^n): Exponential Growth 指数\n- O(n!): Factorial 阶乘\n- ![时间复杂度](http://p0.meituan.net/myvideodistribute/c88294c6a8b88448ae14e2914c7bbfd2337181.png)\n\n#### master theorem\n- 二分查找\n- 二叉树的遍历（每个节点都访问一次，且仅访问一次）\n- 二维有序矩阵\n- 归并排序 O(nlogn)\n- ![主定理](http://p1.meituan.net/myvideodistribute/5b978d58635ea2e9233ea5e502ab706f246540.png)","slug":"Elle-训练算法计划","published":1,"updated":"2020-04-06T13:17:48.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8x6bfzr0001zsp3a2v0a724","content":"<h4 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h4><ul>\n<li>简单记录一下自己整个算法训练的基础步骤+学习方法</li>\n<li>主要的数据结构和算法会单开文档来写</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"Chunk-it-up-切碎知识点\"><a href=\"#Chunk-it-up-切碎知识点\" class=\"headerlink\" title=\"Chunk it up 切碎知识点\"></a>Chunk it up 切碎知识点</h4><ul>\n<li>数据结构<ul>\n<li>一维数据结构<ul>\n<li>基础：数组 array(string), 链表 linked list</li>\n<li>高级：栈 stack, 队列 queue, 双端队列 deque, 集合 set, 映射 map (hash or map), etc</li>\n</ul>\n</li>\n<li>二维数据结构<ul>\n<li>一维泛化</li>\n<li>基础：树 tree，图 graph</li>\n<li>高级：二叉搜索树 binary search tree (red-black tree, AVL)，堆 heap, 并查集 disjoint set, 字典树 trie, etc</li>\n</ul>\n</li>\n<li>特殊数据结构<ul>\n<li>位运算 bitwise, 布隆过滤器 bloom filter</li>\n<li>LRU Cache</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>算法<ul>\n<li>if-else, switch –&gt; branch</li>\n<li>for, while loop –&gt; iteration</li>\n<li>递归 recursion (divide &amp; conquer 分治, backtrace 回溯)</li>\n<li>搜索 search: 深度优先搜索 depth first search, 广度优先搜索 breadth first search, A* (启发式搜索), etc</li>\n<li>动态规划 dynamic programing</li>\n<li>二分查找 binary search</li>\n<li>贪心 greedy</li>\n<li>数学 math, 集合 geometry</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Deliberate-Practicing-刻意练习\"><a href=\"#Deliberate-Practicing-刻意练习\" class=\"headerlink\" title=\"Deliberate Practicing 刻意练习\"></a>Deliberate Practicing 刻意练习</h4><ul>\n<li>刻意练习-过遍数 (五遍刷题法)<ul>\n<li>刷题第一遍<ul>\n<li>5分钟（5~15 mins）：读题+思考</li>\n<li>直接看解法：注意！多解法，比较解乏优劣</li>\n<li>有思路，直接写</li>\n<li>背诵+默写好的解法</li>\n</ul>\n</li>\n<li>刷题第二遍<ul>\n<li>马上自己写 –&gt; LeetCode提交</li>\n<li>多种解法比较、体会 –&gt; 优化</li>\n<li>多种解法自己写一遍，直到通过</li>\n</ul>\n</li>\n<li>刷题第三遍<ul>\n<li>24h后，再重复做题</li>\n<li>不同解法的熟练程度 –&gt; 专项练习</li>\n</ul>\n</li>\n<li>刷题第四遍<ul>\n<li>过了一周后：反复回来练习相同的题目</li>\n<li>不熟练的题目 –&gt; 专项练习</li>\n</ul>\n</li>\n<li>刷题第五遍<ul>\n<li>面试前二周恢复性训练</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>练习缺陷、弱点地方<ul>\n<li>中文站 leetcode-cn.com 刷题</li>\n<li>国际站 leetcode.com 看discuss-most votes</li>\n</ul>\n</li>\n<li>切题<ul>\n<li><strong>Clarification 审题</strong></li>\n<li><strong>Possible Solutions</strong><ul>\n<li>compare (time/space)</li>\n<li>optimal (加强)</li>\n</ul>\n</li>\n<li><strong>Coding</strong></li>\n<li><strong>Test cases</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Feedback-反馈\"><a href=\"#Feedback-反馈\" class=\"headerlink\" title=\"Feedback 反馈\"></a>Feedback 反馈</h4><ul>\n<li>即时反馈</li>\n<li>主动型反馈</li>\n<li>被动型反馈<ul>\n<li>code review</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"指法\"><a href=\"#指法\" class=\"headerlink\" title=\"指法\"></a>指法</h4><ul>\n<li>top tips for vscode</li>\n</ul>\n<h4 id=\"自顶向下的编程方式\"><a href=\"#自顶向下的编程方式\" class=\"headerlink\" title=\"自顶向下的编程方式\"></a>自顶向下的编程方式</h4><ul>\n<li><a href=\"http://markhneedham.com/blog/2008/09/15/clean-code-book-review/\" target=\"_blank\" rel=\"noopener\">自顶向下的编程方式</a></li>\n</ul>\n<h4 id=\"Big-O-Notation\"><a href=\"#Big-O-Notation\" class=\"headerlink\" title=\"Big O Notation\"></a>Big O Notation</h4><ul>\n<li>O(1): constant Complexity 常数复杂度</li>\n<li>O(log n): Logarithmic Complexity 对数复杂度</li>\n<li>O(n): Linear Complexity 线性时间复杂度</li>\n<li>O(n^2): N square Complexity 平方</li>\n<li>O(n^3): N cube Complexity 立方</li>\n<li>O(2^n): Exponential Growth 指数</li>\n<li>O(n!): Factorial 阶乘</li>\n<li><img src=\"http://p0.meituan.net/myvideodistribute/c88294c6a8b88448ae14e2914c7bbfd2337181.png\" alt=\"时间复杂度\"></li>\n</ul>\n<h4 id=\"master-theorem\"><a href=\"#master-theorem\" class=\"headerlink\" title=\"master theorem\"></a>master theorem</h4><ul>\n<li>二分查找</li>\n<li>二叉树的遍历（每个节点都访问一次，且仅访问一次）</li>\n<li>二维有序矩阵</li>\n<li>归并排序 O(nlogn)</li>\n<li><img src=\"http://p1.meituan.net/myvideodistribute/5b978d58635ea2e9233ea5e502ab706f246540.png\" alt=\"主定理\"></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h4><ul>\n<li>简单记录一下自己整个算法训练的基础步骤+学习方法</li>\n<li>主要的数据结构和算法会单开文档来写</li>\n</ul>","more":"<h4 id=\"Chunk-it-up-切碎知识点\"><a href=\"#Chunk-it-up-切碎知识点\" class=\"headerlink\" title=\"Chunk it up 切碎知识点\"></a>Chunk it up 切碎知识点</h4><ul>\n<li>数据结构<ul>\n<li>一维数据结构<ul>\n<li>基础：数组 array(string), 链表 linked list</li>\n<li>高级：栈 stack, 队列 queue, 双端队列 deque, 集合 set, 映射 map (hash or map), etc</li>\n</ul>\n</li>\n<li>二维数据结构<ul>\n<li>一维泛化</li>\n<li>基础：树 tree，图 graph</li>\n<li>高级：二叉搜索树 binary search tree (red-black tree, AVL)，堆 heap, 并查集 disjoint set, 字典树 trie, etc</li>\n</ul>\n</li>\n<li>特殊数据结构<ul>\n<li>位运算 bitwise, 布隆过滤器 bloom filter</li>\n<li>LRU Cache</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>算法<ul>\n<li>if-else, switch –&gt; branch</li>\n<li>for, while loop –&gt; iteration</li>\n<li>递归 recursion (divide &amp; conquer 分治, backtrace 回溯)</li>\n<li>搜索 search: 深度优先搜索 depth first search, 广度优先搜索 breadth first search, A* (启发式搜索), etc</li>\n<li>动态规划 dynamic programing</li>\n<li>二分查找 binary search</li>\n<li>贪心 greedy</li>\n<li>数学 math, 集合 geometry</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Deliberate-Practicing-刻意练习\"><a href=\"#Deliberate-Practicing-刻意练习\" class=\"headerlink\" title=\"Deliberate Practicing 刻意练习\"></a>Deliberate Practicing 刻意练习</h4><ul>\n<li>刻意练习-过遍数 (五遍刷题法)<ul>\n<li>刷题第一遍<ul>\n<li>5分钟（5~15 mins）：读题+思考</li>\n<li>直接看解法：注意！多解法，比较解乏优劣</li>\n<li>有思路，直接写</li>\n<li>背诵+默写好的解法</li>\n</ul>\n</li>\n<li>刷题第二遍<ul>\n<li>马上自己写 –&gt; LeetCode提交</li>\n<li>多种解法比较、体会 –&gt; 优化</li>\n<li>多种解法自己写一遍，直到通过</li>\n</ul>\n</li>\n<li>刷题第三遍<ul>\n<li>24h后，再重复做题</li>\n<li>不同解法的熟练程度 –&gt; 专项练习</li>\n</ul>\n</li>\n<li>刷题第四遍<ul>\n<li>过了一周后：反复回来练习相同的题目</li>\n<li>不熟练的题目 –&gt; 专项练习</li>\n</ul>\n</li>\n<li>刷题第五遍<ul>\n<li>面试前二周恢复性训练</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>练习缺陷、弱点地方<ul>\n<li>中文站 leetcode-cn.com 刷题</li>\n<li>国际站 leetcode.com 看discuss-most votes</li>\n</ul>\n</li>\n<li>切题<ul>\n<li><strong>Clarification 审题</strong></li>\n<li><strong>Possible Solutions</strong><ul>\n<li>compare (time/space)</li>\n<li>optimal (加强)</li>\n</ul>\n</li>\n<li><strong>Coding</strong></li>\n<li><strong>Test cases</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Feedback-反馈\"><a href=\"#Feedback-反馈\" class=\"headerlink\" title=\"Feedback 反馈\"></a>Feedback 反馈</h4><ul>\n<li>即时反馈</li>\n<li>主动型反馈</li>\n<li>被动型反馈<ul>\n<li>code review</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"指法\"><a href=\"#指法\" class=\"headerlink\" title=\"指法\"></a>指法</h4><ul>\n<li>top tips for vscode</li>\n</ul>\n<h4 id=\"自顶向下的编程方式\"><a href=\"#自顶向下的编程方式\" class=\"headerlink\" title=\"自顶向下的编程方式\"></a>自顶向下的编程方式</h4><ul>\n<li><a href=\"http://markhneedham.com/blog/2008/09/15/clean-code-book-review/\" target=\"_blank\" rel=\"noopener\">自顶向下的编程方式</a></li>\n</ul>\n<h4 id=\"Big-O-Notation\"><a href=\"#Big-O-Notation\" class=\"headerlink\" title=\"Big O Notation\"></a>Big O Notation</h4><ul>\n<li>O(1): constant Complexity 常数复杂度</li>\n<li>O(log n): Logarithmic Complexity 对数复杂度</li>\n<li>O(n): Linear Complexity 线性时间复杂度</li>\n<li>O(n^2): N square Complexity 平方</li>\n<li>O(n^3): N cube Complexity 立方</li>\n<li>O(2^n): Exponential Growth 指数</li>\n<li>O(n!): Factorial 阶乘</li>\n<li><img src=\"http://p0.meituan.net/myvideodistribute/c88294c6a8b88448ae14e2914c7bbfd2337181.png\" alt=\"时间复杂度\"></li>\n</ul>\n<h4 id=\"master-theorem\"><a href=\"#master-theorem\" class=\"headerlink\" title=\"master theorem\"></a>master theorem</h4><ul>\n<li>二分查找</li>\n<li>二叉树的遍历（每个节点都访问一次，且仅访问一次）</li>\n<li>二维有序矩阵</li>\n<li>归并排序 O(nlogn)</li>\n<li><img src=\"http://p1.meituan.net/myvideodistribute/5b978d58635ea2e9233ea5e502ab706f246540.png\" alt=\"主定理\"></li>\n</ul>"},{"title":"自己的前端知识体系","date":"2020-04-12T14:48:53.000Z","description":["理一下自己的技术体系吧"],"_content":"\n### 写在前面\n- 理一下自己的技术体系吧\n\n<!-- more -->\n\n### 技术体系脑图\n- ![技术体系脑图](http://p1.meituan.net/myvideodistribute/4f20126926dd47b1b314ffb5f0361d384342943.png)\n\n### 写在后面\n- 祝大家多多发财\n","source":"_posts/自己的前端知识体系.md","raw":"---\ntitle: 自己的前端知识体系\ndate: 2020-04-12 22:48:53\ntags: \n- 前端概念\ncategories:\n- 前端概念\ndescription:\n- 理一下自己的技术体系吧\n---\n\n### 写在前面\n- 理一下自己的技术体系吧\n\n<!-- more -->\n\n### 技术体系脑图\n- ![技术体系脑图](http://p1.meituan.net/myvideodistribute/4f20126926dd47b1b314ffb5f0361d384342943.png)\n\n### 写在后面\n- 祝大家多多发财\n","slug":"自己的前端知识体系","published":1,"updated":"2020-04-12T14:58:19.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8x6bfzt0002zsp34o0i4erx","content":"<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><ul>\n<li>理一下自己的技术体系吧</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"技术体系脑图\"><a href=\"#技术体系脑图\" class=\"headerlink\" title=\"技术体系脑图\"></a>技术体系脑图</h3><ul>\n<li><img src=\"http://p1.meituan.net/myvideodistribute/4f20126926dd47b1b314ffb5f0361d384342943.png\" alt=\"技术体系脑图\"></li>\n</ul>\n<h3 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h3><ul>\n<li>祝大家多多发财</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><ul>\n<li>理一下自己的技术体系吧</li>\n</ul>","more":"<h3 id=\"技术体系脑图\"><a href=\"#技术体系脑图\" class=\"headerlink\" title=\"技术体系脑图\"></a>技术体系脑图</h3><ul>\n<li><img src=\"http://p1.meituan.net/myvideodistribute/4f20126926dd47b1b314ffb5f0361d384342943.png\" alt=\"技术体系脑图\"></li>\n</ul>\n<h3 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h3><ul>\n<li>祝大家多多发财</li>\n</ul>"},{"layout":"微信小程序-气泡框","title":"微信小程序-气泡框","date":"2020-04-05T03:47:05.000Z","description":["记录基于[微信小程序-气泡框](https://developers.weixin.qq.com/community/develop/doc/000e4e7103c3c090e517e0cdb5b806)实现中产生的问题及思考"],"_content":"\n####  写在前面\n- 记录基于[微信小程序-气泡框](https://developers.weixin.qq.com/community/develop/doc/000e4e7103c3c090e517e0cdb5b806)实现中产生的问题及思考\n- - -\n#### 问题截图\n![popover问题截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzlkMGY1NmUxOTVkNzFjMjAyYzVkYzI0OGMxMzg0NmUxMTQ3MTQucG5n?x-oss-process=image/format,png)\n#### 问题描述\n- 模拟器显示正常，但在真机上点击后，气泡框的箭头并没有消失，且点击同一级别区域，能利用覆盖消除箭头。【是不是一个很可爱的bug？\n<!-- more -->\n\n#### 问题解决过程记录\n- 定位问题发生的原因范围\n\t- 样式\n\t\t- 样式在判断显示条件(wx:if=\"{{visible}}\")生效后，仍然渲染\n\t\t- 否定原因\n\t\t\t- 查询代码发现，整个样式背景的设定是在::before伪元素选择器中\n\t\t\t- 且显示条件生效，在调试器中已没有该元素，但仍显示\n\t- 逻辑\n\t\t- 会不会是组件在渲染时，多渲染一份，我们使用判断条件进行开关时，只是对其中一个进行了操作\n\t\t- 怀疑依据\n\t\t\t- ![popover问题依据截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzk5ZjcwMDAwZmViM2IwYzc0MWJmNjFiYzE5YTUwMDIxMjYyMTI3LnBuZw?x-oss-process=image/format,png)\n\t\t\t- 上图可见：在popover组件下，有2个通过&lt;slot&gt;插入的相同内容\n\n- 开始解决问题\n\t- 查询官方关于[slot](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html)方面的介绍\n\t\t- ![官方slot基础例子](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2JjMTE0ZmI0YTdhOWZkY2ZlYzU3ZDE5ZWQyYWY0YzI3MzE1NTU4LnBuZw?x-oss-process=image/format,png)\n\t- 基于官方基础代码，复现问题\n\t\t- 产生一个child-tag组件，并在其中编写\n\t\t\t```javascript\n\t\t\t// components/child-tag.js.js\n\t\t\tComponent({\n\t\t\t  options: {\n\t\t\t    multipleSlots: true // 在组件定义时的选项中启用多slot支持\n\t\t\t  },\n\t\t\t  /**\n\t\t\t   * 组件的属性列表\n\t\t\t   */\n\t\t\t  properties: {\n\t\t\t\n\t\t\t  },\n\t\t\t  relations: {\n\t\t\t    './component-tag-name': {\n\t\t\t      type: 'parent',\n\t\t\t    }\n\t\t\t  },\n\t\t\t\n\t\t\t  /**\n\t\t\t   * 组件的初始数据\n\t\t\t   */\n\t\t\t  data: {\n\t\t\t\n\t\t\t  },\n\t\t\t\n\t\t\t  /**\n\t\t\t   * 组件的方法列表\n\t\t\t   */\n\t\t\t  methods: {\n\t\t\t\n\t\t\t  }\n\t\t\t})\n\t\t\t```\n\t\t- 与component-tag-name绑定形成父子组件\n\t\t\t```javascript\n\t\t\t// components/component-tag-name.js\n\t\t\tComponent({\n\t\t\t  options: {\n\t\t\t    multipleSlots: true // 在组件定义时的选项中启用多slot支持\n\t\t\t  },\n\t\t\t  relations: {\n\t\t\t    './child-tag': {\n\t\t\t      type: 'child',\n\t\t\t    }\n\t\t\t  },\n\t\t\t  /**\n\t\t\t   * 组件的属性列表\n\t\t\t   */\n\t\t\t  properties: {\n\t\t\t  },\n\t\t\t\n\t\t\t  /**\n\t\t\t   * 组件的初始数据\n\t\t\t   */\n\t\t\t  data: {\n\t\t\t    visible: false\n\t\t\t  },\n\t\t\t\n\t\t\t  /**\n\t\t\t   * 组件的方法列表\n\t\t\t   */\n\t\t\t  methods: {\n\t\t\t  \n\t\t\t  }\n\t\t\t})\n\t\t\t```\n\t\t- 并将index.html中进行调用\n\t\t\t```html\n\t\t\t<!-- 引用组件的页面模版 -->\n\t\t\t<view>\n\t\t\t  <button type=\"primary\" bindtap=\"onTap\">222</button>\n\t\t\t\t<my-component id=\"component\">\n\t\t\t\t\t<view slot=\"content\">\n\t\t\t\t\t\t这里是插入到组件slot name=\"content\"中的内容\n\t\t\t\t\t\t<child-component>\n\t\t\t\t\t\t\t<view slot=\"child\">这里是插入到组件slot name=\"child\"中的内容</view>\n\t\t\t\t\t\t</child-component>\n\t\t\t\t\t</view>\n\t\t\t\t</my-component>\n\t\t\t</view>\n\t\t\t```\n\t\t- 但是其结构树仍然非常正常，并没有出现那个所谓的\"拷贝\"组件\n\t\t\t- ![改写v1.1后的结构树截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzcwNTRhNjJkYmM2MGEyNmU5ZGI1ODYzNzNjOGY2OTgyMzg3NTI0LnBuZw?x-oss-process=image/format,png)\n\t\t\t- 仔细复现了几次，发现：多出来的那个组件会有所延迟。抓住这个问题，想到我们在onReady中，注册了该组件，于是，继续模拟\n\t\t- 修改index.js代码，并在component-tag-name组件注册onTap方法，控制显隐\n\t\t\t```javascript\n\t\t\t  onReady() {\n\t\t\t    this.component = this.selectComponent('#component')\n\t\t\t  },\n\t\t\t  onTap() {\n\t\t\t    console.log('onTap')\n\t\t\t    wx.createSelectorQuery().select('#component').boundingClientRect(res => {\n\t\t\t        // 调用自定义组件 popover 中的 onDisplay 方法\n\t\t\t        this.component.onTap();\n\t\t\t    }).exec();\n\t\t\t  }\n\t\t\t\t```\n\t\t- 最终复现\n\t\t\t- ![官方模拟最终运行截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzhmZjQ3OTNhMjUwYTNjMzlhYjBlOGQxMGJhYTllZmI2NDc1NjIyLnBuZw?x-oss-process=image/format,png)\n\t- 得出问题来源：\n\t\t- 在组件中进行了一次setData\n\t- 思考背后问题\n\t\t- 在组件中setData为什么会”拷贝“一份相同的在页面级wxml中？\n\t\t- 猜想一：从[WXS响应事件](https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88)中，我隐隐得到了答案\n\t\t- ![wxs相应事件](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzZlYWJjYjdjOTliMzAxNWMwOGQwZmM2YWM3ZmMxMGMzNDU5NDAxLnBuZw?x-oss-process=image/format,png)\n\t\t- 我们在页面级通过selectComponent实例化组件，对选中的组件进行操作，官方可以通过拷贝一份相同的组件，使我们便捷的将事件的处理从2次的逻辑层和渲染层通信以及一次渲染，减少到直接对页面上元素进行操作，即一次逻辑层和渲染层通信以及一次渲染。\n\t\t- 猜想二：问题层面是在微信开发者工具中的wxml，渲染方式对于这种情况就是这样处理的。\n- 官方已给出问题原因\n\t- ![wxml面板](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzJkMWVkZmYyNWIwM2YxZDU2ZGVjYjZhM2NkYjAwMGU5NTE5ODQucG5n?x-oss-process=image/format,png)\n\n#### 如何解决问题\n- 在popover以及popover-item加入\n\t```javascript\n\toptions: {\n\t\t\t    multipleSlots: true // 在组件定义时的选项中启用多slot支持\n\t\t\t  },\n\t```\n- 就可以解决了。最后建议slot中可以写上name这样代码可能会更易读。\n####  写在后面\n- 祝大家多多发财\n---","source":"_posts/微信小程序-气泡框 Popover.md","raw":"---\nlayout: 微信小程序-气泡框\ntitle: 微信小程序-气泡框\ndate: 2020-04-05 11:47:05\ntags: \n- 微信小程序\ncategories:\n- 微信小程序\ndescription:\n  - 记录基于[微信小程序-气泡框](https://developers.weixin.qq.com/community/develop/doc/000e4e7103c3c090e517e0cdb5b806)实现中产生的问题及思考\n\n---\n\n####  写在前面\n- 记录基于[微信小程序-气泡框](https://developers.weixin.qq.com/community/develop/doc/000e4e7103c3c090e517e0cdb5b806)实现中产生的问题及思考\n- - -\n#### 问题截图\n![popover问题截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzlkMGY1NmUxOTVkNzFjMjAyYzVkYzI0OGMxMzg0NmUxMTQ3MTQucG5n?x-oss-process=image/format,png)\n#### 问题描述\n- 模拟器显示正常，但在真机上点击后，气泡框的箭头并没有消失，且点击同一级别区域，能利用覆盖消除箭头。【是不是一个很可爱的bug？\n<!-- more -->\n\n#### 问题解决过程记录\n- 定位问题发生的原因范围\n\t- 样式\n\t\t- 样式在判断显示条件(wx:if=\"{{visible}}\")生效后，仍然渲染\n\t\t- 否定原因\n\t\t\t- 查询代码发现，整个样式背景的设定是在::before伪元素选择器中\n\t\t\t- 且显示条件生效，在调试器中已没有该元素，但仍显示\n\t- 逻辑\n\t\t- 会不会是组件在渲染时，多渲染一份，我们使用判断条件进行开关时，只是对其中一个进行了操作\n\t\t- 怀疑依据\n\t\t\t- ![popover问题依据截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzk5ZjcwMDAwZmViM2IwYzc0MWJmNjFiYzE5YTUwMDIxMjYyMTI3LnBuZw?x-oss-process=image/format,png)\n\t\t\t- 上图可见：在popover组件下，有2个通过&lt;slot&gt;插入的相同内容\n\n- 开始解决问题\n\t- 查询官方关于[slot](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html)方面的介绍\n\t\t- ![官方slot基础例子](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2JjMTE0ZmI0YTdhOWZkY2ZlYzU3ZDE5ZWQyYWY0YzI3MzE1NTU4LnBuZw?x-oss-process=image/format,png)\n\t- 基于官方基础代码，复现问题\n\t\t- 产生一个child-tag组件，并在其中编写\n\t\t\t```javascript\n\t\t\t// components/child-tag.js.js\n\t\t\tComponent({\n\t\t\t  options: {\n\t\t\t    multipleSlots: true // 在组件定义时的选项中启用多slot支持\n\t\t\t  },\n\t\t\t  /**\n\t\t\t   * 组件的属性列表\n\t\t\t   */\n\t\t\t  properties: {\n\t\t\t\n\t\t\t  },\n\t\t\t  relations: {\n\t\t\t    './component-tag-name': {\n\t\t\t      type: 'parent',\n\t\t\t    }\n\t\t\t  },\n\t\t\t\n\t\t\t  /**\n\t\t\t   * 组件的初始数据\n\t\t\t   */\n\t\t\t  data: {\n\t\t\t\n\t\t\t  },\n\t\t\t\n\t\t\t  /**\n\t\t\t   * 组件的方法列表\n\t\t\t   */\n\t\t\t  methods: {\n\t\t\t\n\t\t\t  }\n\t\t\t})\n\t\t\t```\n\t\t- 与component-tag-name绑定形成父子组件\n\t\t\t```javascript\n\t\t\t// components/component-tag-name.js\n\t\t\tComponent({\n\t\t\t  options: {\n\t\t\t    multipleSlots: true // 在组件定义时的选项中启用多slot支持\n\t\t\t  },\n\t\t\t  relations: {\n\t\t\t    './child-tag': {\n\t\t\t      type: 'child',\n\t\t\t    }\n\t\t\t  },\n\t\t\t  /**\n\t\t\t   * 组件的属性列表\n\t\t\t   */\n\t\t\t  properties: {\n\t\t\t  },\n\t\t\t\n\t\t\t  /**\n\t\t\t   * 组件的初始数据\n\t\t\t   */\n\t\t\t  data: {\n\t\t\t    visible: false\n\t\t\t  },\n\t\t\t\n\t\t\t  /**\n\t\t\t   * 组件的方法列表\n\t\t\t   */\n\t\t\t  methods: {\n\t\t\t  \n\t\t\t  }\n\t\t\t})\n\t\t\t```\n\t\t- 并将index.html中进行调用\n\t\t\t```html\n\t\t\t<!-- 引用组件的页面模版 -->\n\t\t\t<view>\n\t\t\t  <button type=\"primary\" bindtap=\"onTap\">222</button>\n\t\t\t\t<my-component id=\"component\">\n\t\t\t\t\t<view slot=\"content\">\n\t\t\t\t\t\t这里是插入到组件slot name=\"content\"中的内容\n\t\t\t\t\t\t<child-component>\n\t\t\t\t\t\t\t<view slot=\"child\">这里是插入到组件slot name=\"child\"中的内容</view>\n\t\t\t\t\t\t</child-component>\n\t\t\t\t\t</view>\n\t\t\t\t</my-component>\n\t\t\t</view>\n\t\t\t```\n\t\t- 但是其结构树仍然非常正常，并没有出现那个所谓的\"拷贝\"组件\n\t\t\t- ![改写v1.1后的结构树截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzcwNTRhNjJkYmM2MGEyNmU5ZGI1ODYzNzNjOGY2OTgyMzg3NTI0LnBuZw?x-oss-process=image/format,png)\n\t\t\t- 仔细复现了几次，发现：多出来的那个组件会有所延迟。抓住这个问题，想到我们在onReady中，注册了该组件，于是，继续模拟\n\t\t- 修改index.js代码，并在component-tag-name组件注册onTap方法，控制显隐\n\t\t\t```javascript\n\t\t\t  onReady() {\n\t\t\t    this.component = this.selectComponent('#component')\n\t\t\t  },\n\t\t\t  onTap() {\n\t\t\t    console.log('onTap')\n\t\t\t    wx.createSelectorQuery().select('#component').boundingClientRect(res => {\n\t\t\t        // 调用自定义组件 popover 中的 onDisplay 方法\n\t\t\t        this.component.onTap();\n\t\t\t    }).exec();\n\t\t\t  }\n\t\t\t\t```\n\t\t- 最终复现\n\t\t\t- ![官方模拟最终运行截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzhmZjQ3OTNhMjUwYTNjMzlhYjBlOGQxMGJhYTllZmI2NDc1NjIyLnBuZw?x-oss-process=image/format,png)\n\t- 得出问题来源：\n\t\t- 在组件中进行了一次setData\n\t- 思考背后问题\n\t\t- 在组件中setData为什么会”拷贝“一份相同的在页面级wxml中？\n\t\t- 猜想一：从[WXS响应事件](https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88)中，我隐隐得到了答案\n\t\t- ![wxs相应事件](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzZlYWJjYjdjOTliMzAxNWMwOGQwZmM2YWM3ZmMxMGMzNDU5NDAxLnBuZw?x-oss-process=image/format,png)\n\t\t- 我们在页面级通过selectComponent实例化组件，对选中的组件进行操作，官方可以通过拷贝一份相同的组件，使我们便捷的将事件的处理从2次的逻辑层和渲染层通信以及一次渲染，减少到直接对页面上元素进行操作，即一次逻辑层和渲染层通信以及一次渲染。\n\t\t- 猜想二：问题层面是在微信开发者工具中的wxml，渲染方式对于这种情况就是这样处理的。\n- 官方已给出问题原因\n\t- ![wxml面板](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzJkMWVkZmYyNWIwM2YxZDU2ZGVjYjZhM2NkYjAwMGU5NTE5ODQucG5n?x-oss-process=image/format,png)\n\n#### 如何解决问题\n- 在popover以及popover-item加入\n\t```javascript\n\toptions: {\n\t\t\t    multipleSlots: true // 在组件定义时的选项中启用多slot支持\n\t\t\t  },\n\t```\n- 就可以解决了。最后建议slot中可以写上name这样代码可能会更易读。\n####  写在后面\n- 祝大家多多发财\n---","slug":"微信小程序-气泡框 Popover","published":1,"updated":"2020-04-06T05:48:22.773Z","comments":1,"photos":[],"link":"","_id":"ck8x6bfzx0005zsp3cvuzg17y","content":"<h4 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h4><ul>\n<li>记录基于<a href=\"https://developers.weixin.qq.com/community/develop/doc/000e4e7103c3c090e517e0cdb5b806\" target=\"_blank\" rel=\"noopener\">微信小程序-气泡框</a>实现中产生的问题及思考</li>\n</ul>\n<hr>\n<h4 id=\"问题截图\"><a href=\"#问题截图\" class=\"headerlink\" title=\"问题截图\"></a>问题截图</h4><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzlkMGY1NmUxOTVkNzFjMjAyYzVkYzI0OGMxMzg0NmUxMTQ3MTQucG5n?x-oss-process=image/format,png\" alt=\"popover问题截图\"></p>\n<h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><ul>\n<li>模拟器显示正常，但在真机上点击后，气泡框的箭头并没有消失，且点击同一级别区域，能利用覆盖消除箭头。【是不是一个很可爱的bug？<a id=\"more\"></a>\n\n</li>\n</ul>\n<h4 id=\"问题解决过程记录\"><a href=\"#问题解决过程记录\" class=\"headerlink\" title=\"问题解决过程记录\"></a>问题解决过程记录</h4><ul>\n<li><p>定位问题发生的原因范围</p>\n<ul>\n<li>样式<ul>\n<li>样式在判断显示条件(wx:if=”“)生效后，仍然渲染</li>\n<li>否定原因<ul>\n<li>查询代码发现，整个样式背景的设定是在::before伪元素选择器中</li>\n<li>且显示条件生效，在调试器中已没有该元素，但仍显示</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>逻辑<ul>\n<li>会不会是组件在渲染时，多渲染一份，我们使用判断条件进行开关时，只是对其中一个进行了操作</li>\n<li>怀疑依据<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzk5ZjcwMDAwZmViM2IwYzc0MWJmNjFiYzE5YTUwMDIxMjYyMTI3LnBuZw?x-oss-process=image/format,png\" alt=\"popover问题依据截图\"></li>\n<li>上图可见：在popover组件下，有2个通过&lt;slot&gt;插入的相同内容</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>开始解决问题</p>\n<ul>\n<li>查询官方关于<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html\" target=\"_blank\" rel=\"noopener\">slot</a>方面的介绍<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2JjMTE0ZmI0YTdhOWZkY2ZlYzU3ZDE5ZWQyYWY0YzI3MzE1NTU4LnBuZw?x-oss-process=image/format,png\" alt=\"官方slot基础例子\"></li>\n</ul>\n</li>\n<li>基于官方基础代码，复现问题<ul>\n<li>产生一个child-tag组件，并在其中编写  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// components/child-tag.js.js</span></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">  options: &#123;</span><br><span class=\"line\">    multipleSlots: <span class=\"literal\">true</span> <span class=\"comment\">// 在组件定义时的选项中启用多slot支持</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 组件的属性列表</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  properties: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  relations: &#123;</span><br><span class=\"line\">    <span class=\"string\">'./component-tag-name'</span>: &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'parent'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 组件的初始数据</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 组件的方法列表</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>与component-tag-name绑定形成父子组件  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// components/component-tag-name.js</span></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">  options: &#123;</span><br><span class=\"line\">    multipleSlots: <span class=\"literal\">true</span> <span class=\"comment\">// 在组件定义时的选项中启用多slot支持</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  relations: &#123;</span><br><span class=\"line\">    <span class=\"string\">'./child-tag'</span>: &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'child'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 组件的属性列表</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  properties: &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 组件的初始数据</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    visible: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 组件的方法列表</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>并将index.html中进行调用  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 引用组件的页面模版 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"primary\"</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">\"onTap\"</span>&gt;</span>222<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">id</span>=<span class=\"string\">\"component\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t这里是插入到组件slot name=\"content\"中的内容</span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">child-component</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"child\"</span>&gt;</span>这里是插入到组件slot name=\"child\"中的内容<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">child-component</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>但是其结构树仍然非常正常，并没有出现那个所谓的”拷贝”组件<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzcwNTRhNjJkYmM2MGEyNmU5ZGI1ODYzNzNjOGY2OTgyMzg3NTI0LnBuZw?x-oss-process=image/format,png\" alt=\"改写v1.1后的结构树截图\"></li>\n<li>仔细复现了几次，发现：多出来的那个组件会有所延迟。抓住这个问题，想到我们在onReady中，注册了该组件，于是，继续模拟</li>\n</ul>\n</li>\n<li>修改index.js代码，并在component-tag-name组件注册onTap方法，控制显隐  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onReady() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.component = <span class=\"keyword\">this</span>.selectComponent(<span class=\"string\">'#component'</span>)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">onTap() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'onTap'</span>)</span><br><span class=\"line\">  wx.createSelectorQuery().select(<span class=\"string\">'#component'</span>).boundingClientRect(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 调用自定义组件 popover 中的 onDisplay 方法</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.component.onTap();</span><br><span class=\"line\">  &#125;).exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>最终复现<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzhmZjQ3OTNhMjUwYTNjMzlhYjBlOGQxMGJhYTllZmI2NDc1NjIyLnBuZw?x-oss-process=image/format,png\" alt=\"官方模拟最终运行截图\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>得出问题来源：<ul>\n<li>在组件中进行了一次setData</li>\n</ul>\n</li>\n<li>思考背后问题<ul>\n<li>在组件中setData为什么会”拷贝“一份相同的在页面级wxml中？</li>\n<li>猜想一：从<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88\" target=\"_blank\" rel=\"noopener\">WXS响应事件</a>中，我隐隐得到了答案</li>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzZlYWJjYjdjOTliMzAxNWMwOGQwZmM2YWM3ZmMxMGMzNDU5NDAxLnBuZw?x-oss-process=image/format,png\" alt=\"wxs相应事件\"></li>\n<li>我们在页面级通过selectComponent实例化组件，对选中的组件进行操作，官方可以通过拷贝一份相同的组件，使我们便捷的将事件的处理从2次的逻辑层和渲染层通信以及一次渲染，减少到直接对页面上元素进行操作，即一次逻辑层和渲染层通信以及一次渲染。</li>\n<li>猜想二：问题层面是在微信开发者工具中的wxml，渲染方式对于这种情况就是这样处理的。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>官方已给出问题原因</p>\n<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzJkMWVkZmYyNWIwM2YxZDU2ZGVjYjZhM2NkYjAwMGU5NTE5ODQucG5n?x-oss-process=image/format,png\" alt=\"wxml面板\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"如何解决问题\"><a href=\"#如何解决问题\" class=\"headerlink\" title=\"如何解决问题\"></a>如何解决问题</h4><ul>\n<li>在popover以及popover-item加入  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">options: &#123;</span><br><span class=\"line\">\t\t    multipleSlots: <span class=\"literal\">true</span> <span class=\"comment\">// 在组件定义时的选项中启用多slot支持</span></span><br><span class=\"line\">\t\t  &#125;,</span><br></pre></td></tr></table></figure></li>\n<li>就可以解决了。最后建议slot中可以写上name这样代码可能会更易读。<h4 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h4></li>\n<li>祝大家多多发财</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"<h4 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h4><ul>\n<li>记录基于<a href=\"https://developers.weixin.qq.com/community/develop/doc/000e4e7103c3c090e517e0cdb5b806\" target=\"_blank\" rel=\"noopener\">微信小程序-气泡框</a>实现中产生的问题及思考</li>\n</ul>\n<hr>\n<h4 id=\"问题截图\"><a href=\"#问题截图\" class=\"headerlink\" title=\"问题截图\"></a>问题截图</h4><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzlkMGY1NmUxOTVkNzFjMjAyYzVkYzI0OGMxMzg0NmUxMTQ3MTQucG5n?x-oss-process=image/format,png\" alt=\"popover问题截图\"></p>\n<h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><ul>\n<li>模拟器显示正常，但在真机上点击后，气泡框的箭头并没有消失，且点击同一级别区域，能利用覆盖消除箭头。【是不是一个很可爱的bug？","more":"</li>\n</ul>\n<h4 id=\"问题解决过程记录\"><a href=\"#问题解决过程记录\" class=\"headerlink\" title=\"问题解决过程记录\"></a>问题解决过程记录</h4><ul>\n<li><p>定位问题发生的原因范围</p>\n<ul>\n<li>样式<ul>\n<li>样式在判断显示条件(wx:if=”“)生效后，仍然渲染</li>\n<li>否定原因<ul>\n<li>查询代码发现，整个样式背景的设定是在::before伪元素选择器中</li>\n<li>且显示条件生效，在调试器中已没有该元素，但仍显示</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>逻辑<ul>\n<li>会不会是组件在渲染时，多渲染一份，我们使用判断条件进行开关时，只是对其中一个进行了操作</li>\n<li>怀疑依据<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzk5ZjcwMDAwZmViM2IwYzc0MWJmNjFiYzE5YTUwMDIxMjYyMTI3LnBuZw?x-oss-process=image/format,png\" alt=\"popover问题依据截图\"></li>\n<li>上图可见：在popover组件下，有2个通过&lt;slot&gt;插入的相同内容</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>开始解决问题</p>\n<ul>\n<li>查询官方关于<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html\" target=\"_blank\" rel=\"noopener\">slot</a>方面的介绍<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2JjMTE0ZmI0YTdhOWZkY2ZlYzU3ZDE5ZWQyYWY0YzI3MzE1NTU4LnBuZw?x-oss-process=image/format,png\" alt=\"官方slot基础例子\"></li>\n</ul>\n</li>\n<li>基于官方基础代码，复现问题<ul>\n<li>产生一个child-tag组件，并在其中编写  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// components/child-tag.js.js</span></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">  options: &#123;</span><br><span class=\"line\">    multipleSlots: <span class=\"literal\">true</span> <span class=\"comment\">// 在组件定义时的选项中启用多slot支持</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 组件的属性列表</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  properties: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  relations: &#123;</span><br><span class=\"line\">    <span class=\"string\">'./component-tag-name'</span>: &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'parent'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 组件的初始数据</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 组件的方法列表</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>与component-tag-name绑定形成父子组件  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// components/component-tag-name.js</span></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">  options: &#123;</span><br><span class=\"line\">    multipleSlots: <span class=\"literal\">true</span> <span class=\"comment\">// 在组件定义时的选项中启用多slot支持</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  relations: &#123;</span><br><span class=\"line\">    <span class=\"string\">'./child-tag'</span>: &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'child'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 组件的属性列表</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  properties: &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 组件的初始数据</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    visible: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 组件的方法列表</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>并将index.html中进行调用  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 引用组件的页面模版 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"primary\"</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">\"onTap\"</span>&gt;</span>222<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">id</span>=<span class=\"string\">\"component\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t这里是插入到组件slot name=\"content\"中的内容</span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">child-component</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"child\"</span>&gt;</span>这里是插入到组件slot name=\"child\"中的内容<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">child-component</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>但是其结构树仍然非常正常，并没有出现那个所谓的”拷贝”组件<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzcwNTRhNjJkYmM2MGEyNmU5ZGI1ODYzNzNjOGY2OTgyMzg3NTI0LnBuZw?x-oss-process=image/format,png\" alt=\"改写v1.1后的结构树截图\"></li>\n<li>仔细复现了几次，发现：多出来的那个组件会有所延迟。抓住这个问题，想到我们在onReady中，注册了该组件，于是，继续模拟</li>\n</ul>\n</li>\n<li>修改index.js代码，并在component-tag-name组件注册onTap方法，控制显隐  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onReady() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.component = <span class=\"keyword\">this</span>.selectComponent(<span class=\"string\">'#component'</span>)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">onTap() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'onTap'</span>)</span><br><span class=\"line\">  wx.createSelectorQuery().select(<span class=\"string\">'#component'</span>).boundingClientRect(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 调用自定义组件 popover 中的 onDisplay 方法</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.component.onTap();</span><br><span class=\"line\">  &#125;).exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>最终复现<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzhmZjQ3OTNhMjUwYTNjMzlhYjBlOGQxMGJhYTllZmI2NDc1NjIyLnBuZw?x-oss-process=image/format,png\" alt=\"官方模拟最终运行截图\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>得出问题来源：<ul>\n<li>在组件中进行了一次setData</li>\n</ul>\n</li>\n<li>思考背后问题<ul>\n<li>在组件中setData为什么会”拷贝“一份相同的在页面级wxml中？</li>\n<li>猜想一：从<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88\" target=\"_blank\" rel=\"noopener\">WXS响应事件</a>中，我隐隐得到了答案</li>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzZlYWJjYjdjOTliMzAxNWMwOGQwZmM2YWM3ZmMxMGMzNDU5NDAxLnBuZw?x-oss-process=image/format,png\" alt=\"wxs相应事件\"></li>\n<li>我们在页面级通过selectComponent实例化组件，对选中的组件进行操作，官方可以通过拷贝一份相同的组件，使我们便捷的将事件的处理从2次的逻辑层和渲染层通信以及一次渲染，减少到直接对页面上元素进行操作，即一次逻辑层和渲染层通信以及一次渲染。</li>\n<li>猜想二：问题层面是在微信开发者工具中的wxml，渲染方式对于这种情况就是这样处理的。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>官方已给出问题原因</p>\n<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzJkMWVkZmYyNWIwM2YxZDU2ZGVjYjZhM2NkYjAwMGU5NTE5ODQucG5n?x-oss-process=image/format,png\" alt=\"wxml面板\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"如何解决问题\"><a href=\"#如何解决问题\" class=\"headerlink\" title=\"如何解决问题\"></a>如何解决问题</h4><ul>\n<li>在popover以及popover-item加入  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">options: &#123;</span><br><span class=\"line\">\t\t    multipleSlots: <span class=\"literal\">true</span> <span class=\"comment\">// 在组件定义时的选项中启用多slot支持</span></span><br><span class=\"line\">\t\t  &#125;,</span><br></pre></td></tr></table></figure></li>\n<li>就可以解决了。最后建议slot中可以写上name这样代码可能会更易读。<h4 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h4></li>\n<li>祝大家多多发财</li>\n</ul>\n<hr>"},{"title":"OOP-面向对象","date":"2020-04-09T01:27:29.000Z","description":["昨天 Mentor 说以后要开始用 React Hooks（我还没有涉足 ）写点东西，进而谈论到 React 生态一直想推展开来的的函数式编程思想，我不由得想到一个问题：都说 Javascript 不是典型的面向对象编程语言，它并不具备完整的 OOP 该有的特性，它虽引进了 class 语法糖，但只是让对象原型写法更加像面向对象编程语言的写法，那面向对象到底可以理解为什么 ? 🤔 以及函数式编程思想在推什么？","简单记录一下自己关于这个问题的思考"],"_content":"\n## 写在前面\n- 昨天 Mentor 说以后要开始用 React Hooks（我还没有涉足 ）写点东西，进而谈论到 React 生态一直想推展开来的的函数式编程思想，我不由得想到一个问题：都说 Javascript 不是典型的面向对象编程语言，它并不具备完整的 OOP 该有的特性，它虽引进了 class 语法糖，但只是让对象原型写法更加像面向对象编程语言的写法，那面向对象到底可以理解为什么 ? 🤔 以及函数式编程思想在推什么？Javascript 定位究竟是什么？\n- 简单记录一下自己关于这个问题的思考\n<!-- more -->\n\n## OOP Wikipedia\n- 探讨的是面向对象\n- 我们首先可以想想，我们为什么需要封装成对象？\n\t- 我的理解是：我们需要减少我们的操作粒度，每个操作都去落实到 bit 数据是非常庞大的，减少问题求解复杂度\n\t- wiki 上关于 object 特性也给到了支持\n- A feature of objects is an object's procedures that can **access** and **often modify the data fields** of the object with which they are associated (objects have a notion of \"this\" or \"self\").\n\t- 可以和面向过程 (Procedure Oriented) 放在一起说。\n\t- 首先 OOP 是一个很自然的思想，在C语言中也能写出**符合**面向对象思想的代码\n\t\t\n\t\t```c\n\t\t// C语言例子\n\t\tstruct Student{\n\t\t    char *name;  //姓名\n\t\t    int num;  //学号\n\t\t    int age;  //年龄\n\t\t    char group;  //所在学习小组\n\t\t    float score;  //成绩\n\t\t};\n\t\t\n\t\tchar* GetStudentName(struct Student* stu)\n\t\t{\n\t\t    // 略\n\t\t}\n\t\t\n\t\tvoid SetStudentName(struct Student* stu, char* newName)\n\t\t{\n\t\t    // 略\n\t\t}\n\t\t\n\t\tint main()\n\t\t{\n\t\t    struct Student s1, s2, s3, s4; // 创建了多个学生\n\t\t    SetStudentName(&s1, \"小明\");\n\t\t    SetStudentName(&s2, \"小红\");\n\t\t    return 0;\n\t\t}\n\t\t```\n- 其次 OOP 面向对象编程，在做一件什么事情？\n\t- 在面对复杂性业务需求中，面向对象思想可以将业务先进行分析，如果业务需求全新无关联，那我们可以新建一个对象，在里面封装对应的方法；如果业务需求只是一条延展线（比如特定节假日打折），那我们可以继承现有对象，并对现有对象的某些方法（discount），进行特定操作，即多态：用统一的方法对不同的对象进行同样的操作。\n\t\n\t\t```C++\n\t\toverride fun discount(price: Double): Double {\n\t        if (!isCouple()) return price\n\t        if (price > 99) {\n\t            val lucky = Random().nextInt(gifts.size)\n\t            println(\"Congratulations on getting ${gifts[lucky]}!\")\n\t        }\n\t        return price * 0.77\n\t    }\n\t\t```\n\t\t- 而面对这种频繁操作数据单元的使用面向过程编程思想，可能会在现有对象加上判断，万一节假日还要做其他的业务，判断只会越来越多。这就与我们 Nicklaus Wirth 提出的：**程序 = 数据结构 + 算法**，越来越割裂。\n\t- 在我现在的浅薄思考看来：面向对象编程思想是想先让不同对象以尽可能的统一特性进行归组，形成“大对象”，然后各个对象变成了这个大对象中衍生出来的基类，并在父类派生出来的对象中，去实现各自解决问题的具体方法。这样当我们在拿到一个问题，我们可以不用去管它的内部实现，我们根据类型就可以知道它能做什么事，这比我们手动去一步一步执行要先进点。**让对象有多态性，把不同对象以同一特性来归组，统一处理。至于所谓继承等概念，是实现的细节**。\n\n## prototype-based programming\n- Languages with abstract data type support which may be used to **resemble OO programming**, but **without all features of object-orientation**. This includes object-based and **prototype-based languages**. Examples: JavaScript, Lua, Modula-2, CLU.\n- The Document Object Model of HTML, XHTML, and XML documents on the Internet has bindings to the popular JavaScript/ECMAScript language. **JavaScript is perhaps the best known prototype-based programming language, which employs cloning from prototypes rather than inheriting from a class (contrast to class-based programming)**. \n- 我们在大概了解了 OOP 思想后，我们可以继续看看“类OOP”--基于原型编程 Javascript 实现\n- 我们可以先从 ECMA-262 规范中找到关于 Object 的定义\n\t- \"Objects are created by using constructors in **new expressions**.\"\n\t- \"Each constructor is a function that has a property named **'prototype' that is used to implement prototype-based inheritance and shared properties**.\"\n\t- \"Every object created by a constructor has an implicit reference (called the object's prototype) to the value of its constructor's 'prototype' property. Furthermore, a prototype may have a non-null implicit reference to its prototype, and so on; this is called the prototype chain. When a reference is made to a property in an object, that reference is to the property of that name in the first object in the prototype chain that contains a property of that name. In other words, first the object mentioned directly is examined for such a property; if that object contains the named property, that is the property to which the reference refers; if that object does not contain the named property, the prototype for that object is examined next; and so on.\"\n\t- ![ECMA原型链](http://p0.meituan.net/myvideodistribute/54f432d1395e59da48e0e7935ffd7665110363.png)\n- 同时 Douglas Crockford 关于 [prototypal inheritance](https://crockford.com/javascript/prototypal.html)\n\n\t```javascript\n\tfunction object(o) {\n        function F() {}\n        F.prototype = o;\n        return new F();\n    }\n\t```\n\t- \"The object function untangles JavaScript's constructor pattern, achieving true prototypal inheritance. It takes an old object as a parameter and returns an empty new object that inherits from the old one. If we attempt to obtain a member from the new object, and it lacks that key, then the old object will supply the member. Objects inherit from objects.\"\n\t- \"What could be more object oriented than that?\" 😝\n- 也有新的对 Object 的思考\n\t- \"In JavaScript, **an object is an associative array**, augmented with a prototype (see below); each string key provides the name for an object property, and there are two syntactical ways to specify such a name: dot notation (obj.x = 10) and bracket notation (obj['x'] = 10). A property may be added, rebound, or deleted at run-time. Most properties of an object (and any property that belongs to an object's prototype inheritance chain) can be enumerated using a for...in loop.\"\n\n## Functional programming\n- Functional programming has its origins in lambda calculus.It is a programming paradigm —- a style of building the structure and elements of computer programs -- that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.\n- One of the key motivations for the development of functional programming is making a program easier to understand by eliminating changes in state that **do not depend on function inputs** which are called side effects.\n- side effects include modifying a non-local variable, modifying a static local variable, modifying a mutable argument passed by reference, performing I/O or calling other side-effect functions.\n- referential transparency\n\t- the same language expression can result in different values at different times depending on the state of the executing program.\n\t- Consider C assignment statement x = x * 10, this changes the value assigned to the variable x. Let us say that the initial value of x was 1, then two consecutive evaluations of the variable x yields 10 and 100 respectively. Clearly, replacing x = x * 10 with either 10 or 100 gives a program with different meaning, and so the expression is not referentially transparent. In fact, assignment statements are never referentially transparent.\n\t- Absence of side effects is a necessary, but not sufficient, condition for referential transparency. **Referential transparency means that an expression (such as a function call) can be replaced with its value**. This requires that the expression is pure, that is to say the expression must be deterministic (always give the same value for the same input) and side-effect free.\n\n## 个人总结\n- Javasript 说它是基于面向对象的编程语言是不严谨的，准确的说他是类面向对象的编程语言，基于原型的编程语言。\n\n## 参考文献\n- [引入 Javascript 对象](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects)\n- [Flaws of Object Oriented Modeling](https://software.intel.com/en-us/blogs/2008/08/22/flaws-of-object-oriented-modeling/)\n- [learn object oriented thinking & programming](https://books.google.com/books?id=xb-sAQAAQBAJ&printsec=frontcover&dq=isbn:9788090466180&hl=zh-CN&sa=X&ved=0ahUKEwiG-8y8qdroAhWmUt8KHey5Dl0Q6AEIKDAA#v=onepage&q&f=false)\n- [Obejct thinking](https://books.google.com/books?id=WzsFCAAAQBAJ&printsec=frontcover&dq=isbn:9780735619654&hl=zh-CN&sa=X&ved=0ahUKEwiqzaPSqNroAhVvUd8KHc80CYEQ6AEIKDAA#v=onepage&q&f=false)\n- [Javascript Object-orientation (prototype-based)](https://en.wikipedia.org/wiki/JavaScript)\n- [Introduction to Object Oriented Programming Concepts (OOP) and More](https://www.codeproject.com/Articles/22769/Introduction-to-Object-Oriented-Programming-Concep)\n- [Functional_programming wikipedia](https://en.wikipedia.org/wiki/Functional_programming)\n- [Side effect wikipedia](https://en.wikipedia.org/wiki/Side_effect_(computer_science))\n- [Object-oriented programming wikipedia](https://en.wikipedia.org/wiki/Object-oriented_programming)\n\n\n## 写在后面\n- 有对 Object 以及对 reference 产生的 side effects \n新的认识\n- 闭包 closure\n\t- A nested function is a function defined within another function. It is created each time the outer function is invoked. In addition, each nested function forms a lexical closure: The lexical scope of the outer function (including any constant, local variable, or argument value) becomes part of the internal state of each inner function object, even after execution of the outer function concludes.\n- 祝大家多多发财\n\n\n\n","source":"_posts/OOP-面向对象.md","raw":"---\ntitle: OOP-面向对象\ndate: 2020-04-09 09:27:29\ntags: \n- 前端概念\ncategories:\n- 前端概念\ndescription:\n- 昨天 Mentor 说以后要开始用 React Hooks（我还没有涉足 ）写点东西，进而谈论到 React 生态一直想推展开来的的函数式编程思想，我不由得想到一个问题：都说 Javascript 不是典型的面向对象编程语言，它并不具备完整的 OOP 该有的特性，它虽引进了 class 语法糖，但只是让对象原型写法更加像面向对象编程语言的写法，那面向对象到底可以理解为什么 ? 🤔 以及函数式编程思想在推什么？\n- 简单记录一下自己关于这个问题的思考\n\n\n---\n\n## 写在前面\n- 昨天 Mentor 说以后要开始用 React Hooks（我还没有涉足 ）写点东西，进而谈论到 React 生态一直想推展开来的的函数式编程思想，我不由得想到一个问题：都说 Javascript 不是典型的面向对象编程语言，它并不具备完整的 OOP 该有的特性，它虽引进了 class 语法糖，但只是让对象原型写法更加像面向对象编程语言的写法，那面向对象到底可以理解为什么 ? 🤔 以及函数式编程思想在推什么？Javascript 定位究竟是什么？\n- 简单记录一下自己关于这个问题的思考\n<!-- more -->\n\n## OOP Wikipedia\n- 探讨的是面向对象\n- 我们首先可以想想，我们为什么需要封装成对象？\n\t- 我的理解是：我们需要减少我们的操作粒度，每个操作都去落实到 bit 数据是非常庞大的，减少问题求解复杂度\n\t- wiki 上关于 object 特性也给到了支持\n- A feature of objects is an object's procedures that can **access** and **often modify the data fields** of the object with which they are associated (objects have a notion of \"this\" or \"self\").\n\t- 可以和面向过程 (Procedure Oriented) 放在一起说。\n\t- 首先 OOP 是一个很自然的思想，在C语言中也能写出**符合**面向对象思想的代码\n\t\t\n\t\t```c\n\t\t// C语言例子\n\t\tstruct Student{\n\t\t    char *name;  //姓名\n\t\t    int num;  //学号\n\t\t    int age;  //年龄\n\t\t    char group;  //所在学习小组\n\t\t    float score;  //成绩\n\t\t};\n\t\t\n\t\tchar* GetStudentName(struct Student* stu)\n\t\t{\n\t\t    // 略\n\t\t}\n\t\t\n\t\tvoid SetStudentName(struct Student* stu, char* newName)\n\t\t{\n\t\t    // 略\n\t\t}\n\t\t\n\t\tint main()\n\t\t{\n\t\t    struct Student s1, s2, s3, s4; // 创建了多个学生\n\t\t    SetStudentName(&s1, \"小明\");\n\t\t    SetStudentName(&s2, \"小红\");\n\t\t    return 0;\n\t\t}\n\t\t```\n- 其次 OOP 面向对象编程，在做一件什么事情？\n\t- 在面对复杂性业务需求中，面向对象思想可以将业务先进行分析，如果业务需求全新无关联，那我们可以新建一个对象，在里面封装对应的方法；如果业务需求只是一条延展线（比如特定节假日打折），那我们可以继承现有对象，并对现有对象的某些方法（discount），进行特定操作，即多态：用统一的方法对不同的对象进行同样的操作。\n\t\n\t\t```C++\n\t\toverride fun discount(price: Double): Double {\n\t        if (!isCouple()) return price\n\t        if (price > 99) {\n\t            val lucky = Random().nextInt(gifts.size)\n\t            println(\"Congratulations on getting ${gifts[lucky]}!\")\n\t        }\n\t        return price * 0.77\n\t    }\n\t\t```\n\t\t- 而面对这种频繁操作数据单元的使用面向过程编程思想，可能会在现有对象加上判断，万一节假日还要做其他的业务，判断只会越来越多。这就与我们 Nicklaus Wirth 提出的：**程序 = 数据结构 + 算法**，越来越割裂。\n\t- 在我现在的浅薄思考看来：面向对象编程思想是想先让不同对象以尽可能的统一特性进行归组，形成“大对象”，然后各个对象变成了这个大对象中衍生出来的基类，并在父类派生出来的对象中，去实现各自解决问题的具体方法。这样当我们在拿到一个问题，我们可以不用去管它的内部实现，我们根据类型就可以知道它能做什么事，这比我们手动去一步一步执行要先进点。**让对象有多态性，把不同对象以同一特性来归组，统一处理。至于所谓继承等概念，是实现的细节**。\n\n## prototype-based programming\n- Languages with abstract data type support which may be used to **resemble OO programming**, but **without all features of object-orientation**. This includes object-based and **prototype-based languages**. Examples: JavaScript, Lua, Modula-2, CLU.\n- The Document Object Model of HTML, XHTML, and XML documents on the Internet has bindings to the popular JavaScript/ECMAScript language. **JavaScript is perhaps the best known prototype-based programming language, which employs cloning from prototypes rather than inheriting from a class (contrast to class-based programming)**. \n- 我们在大概了解了 OOP 思想后，我们可以继续看看“类OOP”--基于原型编程 Javascript 实现\n- 我们可以先从 ECMA-262 规范中找到关于 Object 的定义\n\t- \"Objects are created by using constructors in **new expressions**.\"\n\t- \"Each constructor is a function that has a property named **'prototype' that is used to implement prototype-based inheritance and shared properties**.\"\n\t- \"Every object created by a constructor has an implicit reference (called the object's prototype) to the value of its constructor's 'prototype' property. Furthermore, a prototype may have a non-null implicit reference to its prototype, and so on; this is called the prototype chain. When a reference is made to a property in an object, that reference is to the property of that name in the first object in the prototype chain that contains a property of that name. In other words, first the object mentioned directly is examined for such a property; if that object contains the named property, that is the property to which the reference refers; if that object does not contain the named property, the prototype for that object is examined next; and so on.\"\n\t- ![ECMA原型链](http://p0.meituan.net/myvideodistribute/54f432d1395e59da48e0e7935ffd7665110363.png)\n- 同时 Douglas Crockford 关于 [prototypal inheritance](https://crockford.com/javascript/prototypal.html)\n\n\t```javascript\n\tfunction object(o) {\n        function F() {}\n        F.prototype = o;\n        return new F();\n    }\n\t```\n\t- \"The object function untangles JavaScript's constructor pattern, achieving true prototypal inheritance. It takes an old object as a parameter and returns an empty new object that inherits from the old one. If we attempt to obtain a member from the new object, and it lacks that key, then the old object will supply the member. Objects inherit from objects.\"\n\t- \"What could be more object oriented than that?\" 😝\n- 也有新的对 Object 的思考\n\t- \"In JavaScript, **an object is an associative array**, augmented with a prototype (see below); each string key provides the name for an object property, and there are two syntactical ways to specify such a name: dot notation (obj.x = 10) and bracket notation (obj['x'] = 10). A property may be added, rebound, or deleted at run-time. Most properties of an object (and any property that belongs to an object's prototype inheritance chain) can be enumerated using a for...in loop.\"\n\n## Functional programming\n- Functional programming has its origins in lambda calculus.It is a programming paradigm —- a style of building the structure and elements of computer programs -- that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.\n- One of the key motivations for the development of functional programming is making a program easier to understand by eliminating changes in state that **do not depend on function inputs** which are called side effects.\n- side effects include modifying a non-local variable, modifying a static local variable, modifying a mutable argument passed by reference, performing I/O or calling other side-effect functions.\n- referential transparency\n\t- the same language expression can result in different values at different times depending on the state of the executing program.\n\t- Consider C assignment statement x = x * 10, this changes the value assigned to the variable x. Let us say that the initial value of x was 1, then two consecutive evaluations of the variable x yields 10 and 100 respectively. Clearly, replacing x = x * 10 with either 10 or 100 gives a program with different meaning, and so the expression is not referentially transparent. In fact, assignment statements are never referentially transparent.\n\t- Absence of side effects is a necessary, but not sufficient, condition for referential transparency. **Referential transparency means that an expression (such as a function call) can be replaced with its value**. This requires that the expression is pure, that is to say the expression must be deterministic (always give the same value for the same input) and side-effect free.\n\n## 个人总结\n- Javasript 说它是基于面向对象的编程语言是不严谨的，准确的说他是类面向对象的编程语言，基于原型的编程语言。\n\n## 参考文献\n- [引入 Javascript 对象](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects)\n- [Flaws of Object Oriented Modeling](https://software.intel.com/en-us/blogs/2008/08/22/flaws-of-object-oriented-modeling/)\n- [learn object oriented thinking & programming](https://books.google.com/books?id=xb-sAQAAQBAJ&printsec=frontcover&dq=isbn:9788090466180&hl=zh-CN&sa=X&ved=0ahUKEwiG-8y8qdroAhWmUt8KHey5Dl0Q6AEIKDAA#v=onepage&q&f=false)\n- [Obejct thinking](https://books.google.com/books?id=WzsFCAAAQBAJ&printsec=frontcover&dq=isbn:9780735619654&hl=zh-CN&sa=X&ved=0ahUKEwiqzaPSqNroAhVvUd8KHc80CYEQ6AEIKDAA#v=onepage&q&f=false)\n- [Javascript Object-orientation (prototype-based)](https://en.wikipedia.org/wiki/JavaScript)\n- [Introduction to Object Oriented Programming Concepts (OOP) and More](https://www.codeproject.com/Articles/22769/Introduction-to-Object-Oriented-Programming-Concep)\n- [Functional_programming wikipedia](https://en.wikipedia.org/wiki/Functional_programming)\n- [Side effect wikipedia](https://en.wikipedia.org/wiki/Side_effect_(computer_science))\n- [Object-oriented programming wikipedia](https://en.wikipedia.org/wiki/Object-oriented_programming)\n\n\n## 写在后面\n- 有对 Object 以及对 reference 产生的 side effects \n新的认识\n- 闭包 closure\n\t- A nested function is a function defined within another function. It is created each time the outer function is invoked. In addition, each nested function forms a lexical closure: The lexical scope of the outer function (including any constant, local variable, or argument value) becomes part of the internal state of each inner function object, even after execution of the outer function concludes.\n- 祝大家多多发财\n\n\n\n","slug":"OOP-面向对象","published":1,"updated":"2020-04-11T10:44:04.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8x6bg03000gzsp37luzbm5r","content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><ul>\n<li>昨天 Mentor 说以后要开始用 React Hooks（我还没有涉足 ）写点东西，进而谈论到 React 生态一直想推展开来的的函数式编程思想，我不由得想到一个问题：都说 Javascript 不是典型的面向对象编程语言，它并不具备完整的 OOP 该有的特性，它虽引进了 class 语法糖，但只是让对象原型写法更加像面向对象编程语言的写法，那面向对象到底可以理解为什么 ? 🤔 以及函数式编程思想在推什么？Javascript 定位究竟是什么？</li>\n<li>简单记录一下自己关于这个问题的思考<a id=\"more\"></a>\n\n</li>\n</ul>\n<h2 id=\"OOP-Wikipedia\"><a href=\"#OOP-Wikipedia\" class=\"headerlink\" title=\"OOP Wikipedia\"></a>OOP Wikipedia</h2><ul>\n<li><p>探讨的是面向对象</p>\n</li>\n<li><p>我们首先可以想想，我们为什么需要封装成对象？</p>\n<ul>\n<li>我的理解是：我们需要减少我们的操作粒度，每个操作都去落实到 bit 数据是非常庞大的，减少问题求解复杂度</li>\n<li>wiki 上关于 object 特性也给到了支持</li>\n</ul>\n</li>\n<li><p>A feature of objects is an object’s procedures that can <strong>access</strong> and <strong>often modify the data fields</strong> of the object with which they are associated (objects have a notion of “this” or “self”).</p>\n<ul>\n<li><p>可以和面向过程 (Procedure Oriented) 放在一起说。</p>\n</li>\n<li><p>首先 OOP 是一个很自然的思想，在C语言中也能写出<strong>符合</strong>面向对象思想的代码</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C语言例子</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;  <span class=\"comment\">//学号</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;  <span class=\"comment\">//年龄</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> group;  <span class=\"comment\">//所在学习小组</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> score;  <span class=\"comment\">//成绩</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">GetStudentName</span><span class=\"params\">(struct Student* stu)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 略</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetStudentName</span><span class=\"params\">(struct Student* stu, <span class=\"keyword\">char</span>* newName)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 略</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">s1</span>, <span class=\"title\">s2</span>, <span class=\"title\">s3</span>, <span class=\"title\">s4</span>;</span> <span class=\"comment\">// 创建了多个学生</span></span><br><span class=\"line\">    SetStudentName(&amp;s1, <span class=\"string\">\"小明\"</span>);</span><br><span class=\"line\">    SetStudentName(&amp;s2, <span class=\"string\">\"小红\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>其次 OOP 面向对象编程，在做一件什么事情？</p>\n<ul>\n<li><p>在面对复杂性业务需求中，面向对象思想可以将业务先进行分析，如果业务需求全新无关联，那我们可以新建一个对象，在里面封装对应的方法；如果业务需求只是一条延展线（比如特定节假日打折），那我们可以继承现有对象，并对现有对象的某些方法（discount），进行特定操作，即多态：用统一的方法对不同的对象进行同样的操作。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">override</span> fun <span class=\"title\">discount</span><span class=\"params\">(price: Double)</span>: Double </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (!isCouple()) <span class=\"keyword\">return</span> price</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (price &gt; <span class=\"number\">99</span>) &#123;</span><br><span class=\"line\">           val lucky = Random().nextInt(gifts.<span class=\"built_in\">size</span>)</span><br><span class=\"line\">           <span class=\"built_in\">println</span>(<span class=\"string\">\"Congratulations on getting $&#123;gifts[lucky]&#125;!\"</span>)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> price * <span class=\"number\">0.77</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>而面对这种频繁操作数据单元的使用面向过程编程思想，可能会在现有对象加上判断，万一节假日还要做其他的业务，判断只会越来越多。这就与我们 Nicklaus Wirth 提出的：<strong>程序 = 数据结构 + 算法</strong>，越来越割裂。</li>\n</ul>\n</li>\n<li><p>在我现在的浅薄思考看来：面向对象编程思想是想先让不同对象以尽可能的统一特性进行归组，形成“大对象”，然后各个对象变成了这个大对象中衍生出来的基类，并在父类派生出来的对象中，去实现各自解决问题的具体方法。这样当我们在拿到一个问题，我们可以不用去管它的内部实现，我们根据类型就可以知道它能做什么事，这比我们手动去一步一步执行要先进点。<strong>让对象有多态性，把不同对象以同一特性来归组，统一处理。至于所谓继承等概念，是实现的细节</strong>。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"prototype-based-programming\"><a href=\"#prototype-based-programming\" class=\"headerlink\" title=\"prototype-based programming\"></a>prototype-based programming</h2><ul>\n<li><p>Languages with abstract data type support which may be used to <strong>resemble OO programming</strong>, but <strong>without all features of object-orientation</strong>. This includes object-based and <strong>prototype-based languages</strong>. Examples: JavaScript, Lua, Modula-2, CLU.</p>\n</li>\n<li><p>The Document Object Model of HTML, XHTML, and XML documents on the Internet has bindings to the popular JavaScript/ECMAScript language. <strong>JavaScript is perhaps the best known prototype-based programming language, which employs cloning from prototypes rather than inheriting from a class (contrast to class-based programming)</strong>. </p>\n</li>\n<li><p>我们在大概了解了 OOP 思想后，我们可以继续看看“类OOP”–基于原型编程 Javascript 实现</p>\n</li>\n<li><p>我们可以先从 ECMA-262 规范中找到关于 Object 的定义</p>\n<ul>\n<li>“Objects are created by using constructors in <strong>new expressions</strong>.”</li>\n<li>“Each constructor is a function that has a property named <strong>‘prototype’ that is used to implement prototype-based inheritance and shared properties</strong>.”</li>\n<li>“Every object created by a constructor has an implicit reference (called the object’s prototype) to the value of its constructor’s ‘prototype’ property. Furthermore, a prototype may have a non-null implicit reference to its prototype, and so on; this is called the prototype chain. When a reference is made to a property in an object, that reference is to the property of that name in the first object in the prototype chain that contains a property of that name. In other words, first the object mentioned directly is examined for such a property; if that object contains the named property, that is the property to which the reference refers; if that object does not contain the named property, the prototype for that object is examined next; and so on.”</li>\n<li><img src=\"http://p0.meituan.net/myvideodistribute/54f432d1395e59da48e0e7935ffd7665110363.png\" alt=\"ECMA原型链\"></li>\n</ul>\n</li>\n<li><p>同时 Douglas Crockford 关于 <a href=\"https://crockford.com/javascript/prototypal.html\" target=\"_blank\" rel=\"noopener\">prototypal inheritance</a></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">       F.prototype = o;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>“The object function untangles JavaScript’s constructor pattern, achieving true prototypal inheritance. It takes an old object as a parameter and returns an empty new object that inherits from the old one. If we attempt to obtain a member from the new object, and it lacks that key, then the old object will supply the member. Objects inherit from objects.”</li>\n<li>“What could be more object oriented than that?” 😝</li>\n</ul>\n</li>\n<li><p>也有新的对 Object 的思考</p>\n<ul>\n<li>“In JavaScript, <strong>an object is an associative array</strong>, augmented with a prototype (see below); each string key provides the name for an object property, and there are two syntactical ways to specify such a name: dot notation (obj.x = 10) and bracket notation (obj[‘x’] = 10). A property may be added, rebound, or deleted at run-time. Most properties of an object (and any property that belongs to an object’s prototype inheritance chain) can be enumerated using a for…in loop.”</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Functional-programming\"><a href=\"#Functional-programming\" class=\"headerlink\" title=\"Functional programming\"></a>Functional programming</h2><ul>\n<li>Functional programming has its origins in lambda calculus.It is a programming paradigm —- a style of building the structure and elements of computer programs – that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.</li>\n<li>One of the key motivations for the development of functional programming is making a program easier to understand by eliminating changes in state that <strong>do not depend on function inputs</strong> which are called side effects.</li>\n<li>side effects include modifying a non-local variable, modifying a static local variable, modifying a mutable argument passed by reference, performing I/O or calling other side-effect functions.</li>\n<li>referential transparency<ul>\n<li>the same language expression can result in different values at different times depending on the state of the executing program.</li>\n<li>Consider C assignment statement x = x * 10, this changes the value assigned to the variable x. Let us say that the initial value of x was 1, then two consecutive evaluations of the variable x yields 10 and 100 respectively. Clearly, replacing x = x * 10 with either 10 or 100 gives a program with different meaning, and so the expression is not referentially transparent. In fact, assignment statements are never referentially transparent.</li>\n<li>Absence of side effects is a necessary, but not sufficient, condition for referential transparency. <strong>Referential transparency means that an expression (such as a function call) can be replaced with its value</strong>. This requires that the expression is pure, that is to say the expression must be deterministic (always give the same value for the same input) and side-effect free.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"个人总结\"><a href=\"#个人总结\" class=\"headerlink\" title=\"个人总结\"></a>个人总结</h2><ul>\n<li>Javasript 说它是基于面向对象的编程语言是不严谨的，准确的说他是类面向对象的编程语言，基于原型的编程语言。</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects\" target=\"_blank\" rel=\"noopener\">引入 Javascript 对象</a></li>\n<li><a href=\"https://software.intel.com/en-us/blogs/2008/08/22/flaws-of-object-oriented-modeling/\" target=\"_blank\" rel=\"noopener\">Flaws of Object Oriented Modeling</a></li>\n<li><a href=\"https://books.google.com/books?id=xb-sAQAAQBAJ&printsec=frontcover&dq=isbn:9788090466180&hl=zh-CN&sa=X&ved=0ahUKEwiG-8y8qdroAhWmUt8KHey5Dl0Q6AEIKDAA#v=onepage&q&f=false\" target=\"_blank\" rel=\"noopener\">learn object oriented thinking &amp; programming</a></li>\n<li><a href=\"https://books.google.com/books?id=WzsFCAAAQBAJ&printsec=frontcover&dq=isbn:9780735619654&hl=zh-CN&sa=X&ved=0ahUKEwiqzaPSqNroAhVvUd8KHc80CYEQ6AEIKDAA#v=onepage&q&f=false\" target=\"_blank\" rel=\"noopener\">Obejct thinking</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/JavaScript\" target=\"_blank\" rel=\"noopener\">Javascript Object-orientation (prototype-based)</a></li>\n<li><a href=\"https://www.codeproject.com/Articles/22769/Introduction-to-Object-Oriented-Programming-Concep\" target=\"_blank\" rel=\"noopener\">Introduction to Object Oriented Programming Concepts (OOP) and More</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Functional_programming\" target=\"_blank\" rel=\"noopener\">Functional_programming wikipedia</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Side_effect_(computer_science)\" target=\"_blank\" rel=\"noopener\">Side effect wikipedia</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\" target=\"_blank\" rel=\"noopener\">Object-oriented programming wikipedia</a></li>\n</ul>\n<h2 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h2><ul>\n<li>有对 Object 以及对 reference 产生的 side effects<br>新的认识</li>\n<li>闭包 closure<ul>\n<li>A nested function is a function defined within another function. It is created each time the outer function is invoked. In addition, each nested function forms a lexical closure: The lexical scope of the outer function (including any constant, local variable, or argument value) becomes part of the internal state of each inner function object, even after execution of the outer function concludes.</li>\n</ul>\n</li>\n<li>祝大家多多发财</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><ul>\n<li>昨天 Mentor 说以后要开始用 React Hooks（我还没有涉足 ）写点东西，进而谈论到 React 生态一直想推展开来的的函数式编程思想，我不由得想到一个问题：都说 Javascript 不是典型的面向对象编程语言，它并不具备完整的 OOP 该有的特性，它虽引进了 class 语法糖，但只是让对象原型写法更加像面向对象编程语言的写法，那面向对象到底可以理解为什么 ? 🤔 以及函数式编程思想在推什么？Javascript 定位究竟是什么？</li>\n<li>简单记录一下自己关于这个问题的思考","more":"</li>\n</ul>\n<h2 id=\"OOP-Wikipedia\"><a href=\"#OOP-Wikipedia\" class=\"headerlink\" title=\"OOP Wikipedia\"></a>OOP Wikipedia</h2><ul>\n<li><p>探讨的是面向对象</p>\n</li>\n<li><p>我们首先可以想想，我们为什么需要封装成对象？</p>\n<ul>\n<li>我的理解是：我们需要减少我们的操作粒度，每个操作都去落实到 bit 数据是非常庞大的，减少问题求解复杂度</li>\n<li>wiki 上关于 object 特性也给到了支持</li>\n</ul>\n</li>\n<li><p>A feature of objects is an object’s procedures that can <strong>access</strong> and <strong>often modify the data fields</strong> of the object with which they are associated (objects have a notion of “this” or “self”).</p>\n<ul>\n<li><p>可以和面向过程 (Procedure Oriented) 放在一起说。</p>\n</li>\n<li><p>首先 OOP 是一个很自然的思想，在C语言中也能写出<strong>符合</strong>面向对象思想的代码</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C语言例子</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;  <span class=\"comment\">//学号</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;  <span class=\"comment\">//年龄</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> group;  <span class=\"comment\">//所在学习小组</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> score;  <span class=\"comment\">//成绩</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">GetStudentName</span><span class=\"params\">(struct Student* stu)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 略</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetStudentName</span><span class=\"params\">(struct Student* stu, <span class=\"keyword\">char</span>* newName)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 略</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">s1</span>, <span class=\"title\">s2</span>, <span class=\"title\">s3</span>, <span class=\"title\">s4</span>;</span> <span class=\"comment\">// 创建了多个学生</span></span><br><span class=\"line\">    SetStudentName(&amp;s1, <span class=\"string\">\"小明\"</span>);</span><br><span class=\"line\">    SetStudentName(&amp;s2, <span class=\"string\">\"小红\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>其次 OOP 面向对象编程，在做一件什么事情？</p>\n<ul>\n<li><p>在面对复杂性业务需求中，面向对象思想可以将业务先进行分析，如果业务需求全新无关联，那我们可以新建一个对象，在里面封装对应的方法；如果业务需求只是一条延展线（比如特定节假日打折），那我们可以继承现有对象，并对现有对象的某些方法（discount），进行特定操作，即多态：用统一的方法对不同的对象进行同样的操作。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">override</span> fun <span class=\"title\">discount</span><span class=\"params\">(price: Double)</span>: Double </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (!isCouple()) <span class=\"keyword\">return</span> price</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (price &gt; <span class=\"number\">99</span>) &#123;</span><br><span class=\"line\">           val lucky = Random().nextInt(gifts.<span class=\"built_in\">size</span>)</span><br><span class=\"line\">           <span class=\"built_in\">println</span>(<span class=\"string\">\"Congratulations on getting $&#123;gifts[lucky]&#125;!\"</span>)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> price * <span class=\"number\">0.77</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>而面对这种频繁操作数据单元的使用面向过程编程思想，可能会在现有对象加上判断，万一节假日还要做其他的业务，判断只会越来越多。这就与我们 Nicklaus Wirth 提出的：<strong>程序 = 数据结构 + 算法</strong>，越来越割裂。</li>\n</ul>\n</li>\n<li><p>在我现在的浅薄思考看来：面向对象编程思想是想先让不同对象以尽可能的统一特性进行归组，形成“大对象”，然后各个对象变成了这个大对象中衍生出来的基类，并在父类派生出来的对象中，去实现各自解决问题的具体方法。这样当我们在拿到一个问题，我们可以不用去管它的内部实现，我们根据类型就可以知道它能做什么事，这比我们手动去一步一步执行要先进点。<strong>让对象有多态性，把不同对象以同一特性来归组，统一处理。至于所谓继承等概念，是实现的细节</strong>。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"prototype-based-programming\"><a href=\"#prototype-based-programming\" class=\"headerlink\" title=\"prototype-based programming\"></a>prototype-based programming</h2><ul>\n<li><p>Languages with abstract data type support which may be used to <strong>resemble OO programming</strong>, but <strong>without all features of object-orientation</strong>. This includes object-based and <strong>prototype-based languages</strong>. Examples: JavaScript, Lua, Modula-2, CLU.</p>\n</li>\n<li><p>The Document Object Model of HTML, XHTML, and XML documents on the Internet has bindings to the popular JavaScript/ECMAScript language. <strong>JavaScript is perhaps the best known prototype-based programming language, which employs cloning from prototypes rather than inheriting from a class (contrast to class-based programming)</strong>. </p>\n</li>\n<li><p>我们在大概了解了 OOP 思想后，我们可以继续看看“类OOP”–基于原型编程 Javascript 实现</p>\n</li>\n<li><p>我们可以先从 ECMA-262 规范中找到关于 Object 的定义</p>\n<ul>\n<li>“Objects are created by using constructors in <strong>new expressions</strong>.”</li>\n<li>“Each constructor is a function that has a property named <strong>‘prototype’ that is used to implement prototype-based inheritance and shared properties</strong>.”</li>\n<li>“Every object created by a constructor has an implicit reference (called the object’s prototype) to the value of its constructor’s ‘prototype’ property. Furthermore, a prototype may have a non-null implicit reference to its prototype, and so on; this is called the prototype chain. When a reference is made to a property in an object, that reference is to the property of that name in the first object in the prototype chain that contains a property of that name. In other words, first the object mentioned directly is examined for such a property; if that object contains the named property, that is the property to which the reference refers; if that object does not contain the named property, the prototype for that object is examined next; and so on.”</li>\n<li><img src=\"http://p0.meituan.net/myvideodistribute/54f432d1395e59da48e0e7935ffd7665110363.png\" alt=\"ECMA原型链\"></li>\n</ul>\n</li>\n<li><p>同时 Douglas Crockford 关于 <a href=\"https://crockford.com/javascript/prototypal.html\" target=\"_blank\" rel=\"noopener\">prototypal inheritance</a></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">       F.prototype = o;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>“The object function untangles JavaScript’s constructor pattern, achieving true prototypal inheritance. It takes an old object as a parameter and returns an empty new object that inherits from the old one. If we attempt to obtain a member from the new object, and it lacks that key, then the old object will supply the member. Objects inherit from objects.”</li>\n<li>“What could be more object oriented than that?” 😝</li>\n</ul>\n</li>\n<li><p>也有新的对 Object 的思考</p>\n<ul>\n<li>“In JavaScript, <strong>an object is an associative array</strong>, augmented with a prototype (see below); each string key provides the name for an object property, and there are two syntactical ways to specify such a name: dot notation (obj.x = 10) and bracket notation (obj[‘x’] = 10). A property may be added, rebound, or deleted at run-time. Most properties of an object (and any property that belongs to an object’s prototype inheritance chain) can be enumerated using a for…in loop.”</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Functional-programming\"><a href=\"#Functional-programming\" class=\"headerlink\" title=\"Functional programming\"></a>Functional programming</h2><ul>\n<li>Functional programming has its origins in lambda calculus.It is a programming paradigm —- a style of building the structure and elements of computer programs – that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.</li>\n<li>One of the key motivations for the development of functional programming is making a program easier to understand by eliminating changes in state that <strong>do not depend on function inputs</strong> which are called side effects.</li>\n<li>side effects include modifying a non-local variable, modifying a static local variable, modifying a mutable argument passed by reference, performing I/O or calling other side-effect functions.</li>\n<li>referential transparency<ul>\n<li>the same language expression can result in different values at different times depending on the state of the executing program.</li>\n<li>Consider C assignment statement x = x * 10, this changes the value assigned to the variable x. Let us say that the initial value of x was 1, then two consecutive evaluations of the variable x yields 10 and 100 respectively. Clearly, replacing x = x * 10 with either 10 or 100 gives a program with different meaning, and so the expression is not referentially transparent. In fact, assignment statements are never referentially transparent.</li>\n<li>Absence of side effects is a necessary, but not sufficient, condition for referential transparency. <strong>Referential transparency means that an expression (such as a function call) can be replaced with its value</strong>. This requires that the expression is pure, that is to say the expression must be deterministic (always give the same value for the same input) and side-effect free.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"个人总结\"><a href=\"#个人总结\" class=\"headerlink\" title=\"个人总结\"></a>个人总结</h2><ul>\n<li>Javasript 说它是基于面向对象的编程语言是不严谨的，准确的说他是类面向对象的编程语言，基于原型的编程语言。</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects\" target=\"_blank\" rel=\"noopener\">引入 Javascript 对象</a></li>\n<li><a href=\"https://software.intel.com/en-us/blogs/2008/08/22/flaws-of-object-oriented-modeling/\" target=\"_blank\" rel=\"noopener\">Flaws of Object Oriented Modeling</a></li>\n<li><a href=\"https://books.google.com/books?id=xb-sAQAAQBAJ&printsec=frontcover&dq=isbn:9788090466180&hl=zh-CN&sa=X&ved=0ahUKEwiG-8y8qdroAhWmUt8KHey5Dl0Q6AEIKDAA#v=onepage&q&f=false\" target=\"_blank\" rel=\"noopener\">learn object oriented thinking &amp; programming</a></li>\n<li><a href=\"https://books.google.com/books?id=WzsFCAAAQBAJ&printsec=frontcover&dq=isbn:9780735619654&hl=zh-CN&sa=X&ved=0ahUKEwiqzaPSqNroAhVvUd8KHc80CYEQ6AEIKDAA#v=onepage&q&f=false\" target=\"_blank\" rel=\"noopener\">Obejct thinking</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/JavaScript\" target=\"_blank\" rel=\"noopener\">Javascript Object-orientation (prototype-based)</a></li>\n<li><a href=\"https://www.codeproject.com/Articles/22769/Introduction-to-Object-Oriented-Programming-Concep\" target=\"_blank\" rel=\"noopener\">Introduction to Object Oriented Programming Concepts (OOP) and More</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Functional_programming\" target=\"_blank\" rel=\"noopener\">Functional_programming wikipedia</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Side_effect_(computer_science)\" target=\"_blank\" rel=\"noopener\">Side effect wikipedia</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\" target=\"_blank\" rel=\"noopener\">Object-oriented programming wikipedia</a></li>\n</ul>\n<h2 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h2><ul>\n<li>有对 Object 以及对 reference 产生的 side effects<br>新的认识</li>\n<li>闭包 closure<ul>\n<li>A nested function is a function defined within another function. It is created each time the outer function is invoked. In addition, each nested function forms a lexical closure: The lexical scope of the outer function (including any constant, local variable, or argument value) becomes part of the internal state of each inner function object, even after execution of the outer function concludes.</li>\n</ul>\n</li>\n<li>祝大家多多发财</li>\n</ul>"},{"layout":"微信小程序-fix canvas原生组件最顶层","title":"微信小程序-fix canvas原生组件最顶层","date":"2020-04-05T04:04:24.000Z","description":["大家应该都知道过，在微信小程序中，canvas等原生组件的层级是最高的，页面中无论你设置多大的z-index都无法覆盖在其之上，这就可能会产生一些问题"],"_content":"\n#### 写在前面\n- 大家应该都知道过，在微信小程序中，canvas等原生组件的层级是最高的，页面中无论你设置多大的z-index都无法覆盖在其之上，这就可能会产生一些问题\n- 就像这样\n\t- ![canvas顶层问题截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2UxYmQ5OTM2M2VkYjU1NTRmYjc5MzBlZDllMTA0ZjEwMTc2MDM0LnBuZw?x-oss-process=image/format,png)\n\t- 柱状图是用canvas画的，它置于了我的tooltip之上。【这看起来真是一个可怕的问题\n  <!-- more -->\n---\n\n#### 解决问题\n- 微信官方提供了[cover-view](https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html)原生组件，覆盖在原生组件之上的文本视图\n- 微信官方提供了将canvas转化为图片的方式--[wx.canvasToTempFilePath](https://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.canvasToTempFilePath.html)，这样就可以”降级“\n\n\n##### 方法一：cover-view\n- 将tooltip用cover-view改写，效果如下\n\t- ![cover-view version0.1 截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2Y0MTZjZjhlMjNiZWEwMjNjYTM1M2JhOGExMDM1MDM2MzYyOTIucG5n?x-oss-process=image/format,png)\n\t- 看上去，是解决了我们的问题，且tooltip后的灰色背景不能滑动了，【妈耶，好棒！\n\t- 但是，这产生了一个：**当文本超出tooltip宽度时，scroll-y: auto，失效了，溢出部分被直接截取**\n\t- 罪魁祸首就是它\n\t\t- ![cover内置样式](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2M5ZDljYjZiZTQ0ZGY3YmJmNmRlMjAxNDM1ZmYzOTJjNDMxNDMucG5n?x-oss-process=image/format,png)\n\t- 那我们可以：\n\t\t- 在tooltip分段内容中加上\n\t\t\t```css\n\t\t\t.modal-layer-content-rule {\n\t\t\t    white-space: pre-wrap;\n\t\t\t}\n\t\t\t```\n\t\t- 在内容wrapper中加上\n\t\t\t```css\n\t\t\t.modal-layer-content {\n\t\t\t    overflow: scroll;\n\t\t\t}\n\t\t\t```\n\t- 完美解决\n\t\t- ![cover-view解决图](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2FhZjRkMDAyODdjZGI4M2Y0NWRhMGVkOTg3Mzc5MGNhNDQxMjkucG5n?x-oss-process=image/format,png)\n##### 方法二：wx.canvasToTempFilePath\n- 首先我们要做的就是将网络图片绘制进canvas，官方关于canvas类型有两种\n![两种canvas类型](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2E4ZjJmNjA5OGYxNmQ4MzY3NWJiN2I3OWY0ZDM1NWM1MTAwMDg3LnBuZw?x-oss-process=image/format,png)\n- 新canvas 2D接口尝试\n\t```javascript\n\tconst query = wx.createSelectorQuery().in(this)\n    query.select('#myCanvas')\n      .fields({ node: true, size: true })\n      .exec((res) => {\n        const canvas = res[0].node\n        const ctx = canvas.getContext('2d')\n        const img = canvas.createImage()\n        img.onload = () => {\n          ctx.drawImage(img, 0, 0, 100, 100)\n        }\n        img.src = 'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg'\n        // 这种方式获取canvas区域隐含的像素数据\n        console.log(ctx.getImageData(0, 0, 150, 100).data)\n      })\n\t```\n\t```html\n\t<canvas type=\"2d\" id=\"myCanvas\" canvas-id=\"myCanvas\"></canvas>\n\t```\n- 运行截图![canvas2d 运行截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzE5ZWE3ZGYxYjg2ODUzOWFhNzVhY2E0OTAxYzI2MzU2OTk4NDYucG5n?x-oss-process=image/format,png)\n- 第二种旧canvas\n\t```javascript\n\tconst ctx = wx.createCanvasContext('myCanvas')\n    wx.getImageInfo({\n        src: 'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg',\n        success: function (res) {\n          console.log('res', res)\n          const poster = res.path                                  \n          ctx.drawImage(poster, 0, 0, 150, 100)\n          ctx.draw()\n        }\n      })\n      // 这种方式获取canvas区域隐含的像素数据\n      wx.canvasGetImageData({\n        canvasId: 'myCanvas',\n        x: 0,\n        y: 0,\n        width: 150,\n        height: 100,\n        success(res) {\n          console.log(res.width) // 150\n          console.log(res.height) // 100\n          console.log(res.data instanceof Uint8ClampedArray) // true\n          console.log(res.data) // 150 * 100 * 4\n          console.log(res.data.length) // 150 * 100 * 4\n        }\n      })\n\t```\n\t```html\n\t<canvas id=\"myCanvas\" canvas-id=\"myCanvas\"></canvas>\n\t```\n- 运行截图![旧canvas](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzU4NTg5MzQ4MDc3Njk3OTA0OTRmZmIzOWRiNDdjMWRmNjk4ODQucG5n?x-oss-process=image/format,png)\n- 虽然两种方法，都能实现将网络图片绘制进canvas，但新版的进行了createImage，将其打印的话，其实就是新建了一个img标签，并将img标签的东西绘制进canvas\n\t- ![img console](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzFjMjE1NzMzZTRkY2UzNGZiNzI4NDFhZWEyMDc0ZWIwMjQ1OTQucG5n?x-oss-process=image/format,png)\n\t- 为什么微信官方会仅支持以下方式进行新版canvas2d 图片的绘制，考虑是什么？\n\t- ![经典报错](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2JhYWQ1OWRhNDI4M2FjZmViZTY1NGQ0ZWZiNTAxZDZlMjAxMjE2LnBuZw?x-oss-process=image/format,png)\n- 现在我们要将canvas的内容导成图片，同样分成新旧两版\n- 主要思路都是：在wxml中，如果canvas绘制图片没有完成，则显示canvas内容，绘制完成后，就利用canvasToTempFilePath，将图层内容生成指定大小图片，显示image\n\t- canvas2d \n\t\t```javascript\n\t\tconst that = this\n\t    const query = wx.createSelectorQuery().in(this)\n\t    query.select('#myCanvas')\n\t      .fields({ node: true, size: true })\n\t      .exec((res) => {\n\t        const canvas = res[0].node\n\t        const ctx = canvas.getContext('2d')\n\t        const img = canvas.createImage()\n\t        console.log('img', img)\n\t        img.onload = () => {\n\t          ctx.drawImage(img, 0, 0, 100, 100)\n\t            wx.canvasToTempFilePath({\n\t              x: 0,\n\t              y: 0,\n\t              width: 100,\n\t              height: 100,\n\t              destWidth: 100,\n\t              destHeight: 100,\n\t              canvas: canvas,\n\t              success(res) {\n\t                that.setData({\n\t                  imgPath: res.tempFilePath\n\t                })\n\t              },\n\t              fail(err) {\n\t                console.log('err', err)\n\t              }\n\t            })\n\t        }\n\t        img.src = 'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg'\n\t        // 这种方式获取canvas区域隐含的像素数据\n\t        console.log(ctx.getImageData(0, 0, 100, 100).data)\n\t      })\n\t\t```\n\t\t```html\n\t\t<canvas wx:if=\"{{!imgPath}}\" type=\"2d\" id=\"myCanvas\" canvas-id=\"myCanvas\" style=\"width: 330px;height: 340px;\"></canvas>\n\t\t<image wx:else src=\"{{imgPath}}\" style=\"width: 330px;height: 340px;\" />\n\t\t```\n\t\t- canvas2d 需要踩得坑是：它的官方文档🙃\n\t\t\t- ![canvas2d 转图片误导](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2UwM2Q1ZDg0YzYyNmI0NzlmZjBjOTlmNzA1YmRhYjg5NDc5MjcucG5n?x-oss-process=image/format,png)\n\t\t\t- 尝试下来，会\n\t\t\t\t- ![ctx.draw报错](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2UxMjRiY2Q3ZmNjYWI5ODBlNDdkMTk2YTMyZGQyODI4NDUzODcucG5n?x-oss-process=image/format,png)\n\t\t\t- 那我们可以继续往下看\n\t\t\t\t- ![canvas2d tempath正确实力](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2YxODk5NWFiNDY4N2IwYmZlYzhjZTZkZWU2ZWQxYmZjMTA1MTY1LnBuZw?x-oss-process=image/format,png)这才是符合我们需要\n\t\t- 运行截图\n\t\t\t- ![canvas2d运行截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2JmMzVlMzY4YzRjMmRhYTgxNTA0NzM0YTIxZGMxM2I2NDYwNzIucG5n?x-oss-process=image/format,png)\n\t- 旧版canvas\n\t\t```javascript\n\t    const ctx = wx.createCanvasContext('myCanvas')\n\t    const that = this\n\t    wx.getImageInfo({\n\t      src: 'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg',\n\t      success: function (res) {\n\t        console.log('res', res)\n\t        const poster = res.path\n\t        ctx.drawImage(poster, 0, 0, 150, 100)\n\t        ctx.draw(false, () => {\n\t          wx.canvasToTempFilePath({\n\t            x: 0,\n\t            y: 0,\n\t            width: 100,\n\t            height: 100,\n\t            destWidth: 100,\n\t            destHeight: 100,\n\t            canvasId: \"myCanvas\",\n\t            success(res) {\n\t              that.setData({\n\t                imgPath: res.tempFilePath\n\t              })\n\t              console.log(res.tempFilePath)\n\t            },\n\t            fail(err) {\n\t              console.log('err', err)\n\t            }\n\t          })\n\t        })\n\t        // 这种方式获取canvas区域隐含的像素数据\n\t        wx.canvasGetImageData({\n\t          canvasId: 'myCanvas',\n\t          x: 0,\n\t          y: 0,\n\t          width: 150,\n\t          height: 100,\n\t          success(res) {\n\t            console.log(res.width) // 150\n\t            console.log(res.height) // 100\n\t            console.log(res.data instanceof Uint8ClampedArray) // true\n\t            console.log(res.data) // 150 * 100 * 4\n\t            console.log(res.data.length) // 150 * 100 * 4\n\t          }\n\t        })\n\t      }\n\t    })\n\t\t```\n\t\t```html\n\t\t<canvas wx:if=\"{{!imgPath}}\" id=\"myCanvas\" canvas-id=\"myCanvas\" style=\"width: 330px;height: 340px;\"></canvas>\n\t\t<image wx:else src=\"{{imgPath}}\" style=\"width: 330px;height: 340px;\" />\n\t\t```\n\t\t- 运行截图\n\t\t\t- ![旧版canvas运行截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2EzZTRiYTBkYzc2NDgzYTM1NTYxZDcwNDUzNzZkNjZmNDU5MTgucG5n?x-oss-process=image/format,png)\n#### 写在后面\n- 感谢[Skady宝贝](https://github.com/skadieyes)在探讨问题中给予的帮助，欢迎大家去github找她玩👈\n- 祝大家多多发财\n----\n\t\t\n","source":"_posts/微信小程序-fix canvas原生组件最顶层.md","raw":"---\nlayout: 微信小程序-fix canvas原生组件最顶层\ntitle: 微信小程序-fix canvas原生组件最顶层\ndate: 2020-04-05 12:04:24\ntags: \n- 微信小程序\ncategories:\n- 微信小程序\ndescription:\n  - 大家应该都知道过，在微信小程序中，canvas等原生组件的层级是最高的，页面中无论你设置多大的z-index都无法覆盖在其之上，这就可能会产生一些问题\n\n---\n\n#### 写在前面\n- 大家应该都知道过，在微信小程序中，canvas等原生组件的层级是最高的，页面中无论你设置多大的z-index都无法覆盖在其之上，这就可能会产生一些问题\n- 就像这样\n\t- ![canvas顶层问题截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2UxYmQ5OTM2M2VkYjU1NTRmYjc5MzBlZDllMTA0ZjEwMTc2MDM0LnBuZw?x-oss-process=image/format,png)\n\t- 柱状图是用canvas画的，它置于了我的tooltip之上。【这看起来真是一个可怕的问题\n  <!-- more -->\n---\n\n#### 解决问题\n- 微信官方提供了[cover-view](https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html)原生组件，覆盖在原生组件之上的文本视图\n- 微信官方提供了将canvas转化为图片的方式--[wx.canvasToTempFilePath](https://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.canvasToTempFilePath.html)，这样就可以”降级“\n\n\n##### 方法一：cover-view\n- 将tooltip用cover-view改写，效果如下\n\t- ![cover-view version0.1 截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2Y0MTZjZjhlMjNiZWEwMjNjYTM1M2JhOGExMDM1MDM2MzYyOTIucG5n?x-oss-process=image/format,png)\n\t- 看上去，是解决了我们的问题，且tooltip后的灰色背景不能滑动了，【妈耶，好棒！\n\t- 但是，这产生了一个：**当文本超出tooltip宽度时，scroll-y: auto，失效了，溢出部分被直接截取**\n\t- 罪魁祸首就是它\n\t\t- ![cover内置样式](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2M5ZDljYjZiZTQ0ZGY3YmJmNmRlMjAxNDM1ZmYzOTJjNDMxNDMucG5n?x-oss-process=image/format,png)\n\t- 那我们可以：\n\t\t- 在tooltip分段内容中加上\n\t\t\t```css\n\t\t\t.modal-layer-content-rule {\n\t\t\t    white-space: pre-wrap;\n\t\t\t}\n\t\t\t```\n\t\t- 在内容wrapper中加上\n\t\t\t```css\n\t\t\t.modal-layer-content {\n\t\t\t    overflow: scroll;\n\t\t\t}\n\t\t\t```\n\t- 完美解决\n\t\t- ![cover-view解决图](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2FhZjRkMDAyODdjZGI4M2Y0NWRhMGVkOTg3Mzc5MGNhNDQxMjkucG5n?x-oss-process=image/format,png)\n##### 方法二：wx.canvasToTempFilePath\n- 首先我们要做的就是将网络图片绘制进canvas，官方关于canvas类型有两种\n![两种canvas类型](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2E4ZjJmNjA5OGYxNmQ4MzY3NWJiN2I3OWY0ZDM1NWM1MTAwMDg3LnBuZw?x-oss-process=image/format,png)\n- 新canvas 2D接口尝试\n\t```javascript\n\tconst query = wx.createSelectorQuery().in(this)\n    query.select('#myCanvas')\n      .fields({ node: true, size: true })\n      .exec((res) => {\n        const canvas = res[0].node\n        const ctx = canvas.getContext('2d')\n        const img = canvas.createImage()\n        img.onload = () => {\n          ctx.drawImage(img, 0, 0, 100, 100)\n        }\n        img.src = 'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg'\n        // 这种方式获取canvas区域隐含的像素数据\n        console.log(ctx.getImageData(0, 0, 150, 100).data)\n      })\n\t```\n\t```html\n\t<canvas type=\"2d\" id=\"myCanvas\" canvas-id=\"myCanvas\"></canvas>\n\t```\n- 运行截图![canvas2d 运行截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzE5ZWE3ZGYxYjg2ODUzOWFhNzVhY2E0OTAxYzI2MzU2OTk4NDYucG5n?x-oss-process=image/format,png)\n- 第二种旧canvas\n\t```javascript\n\tconst ctx = wx.createCanvasContext('myCanvas')\n    wx.getImageInfo({\n        src: 'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg',\n        success: function (res) {\n          console.log('res', res)\n          const poster = res.path                                  \n          ctx.drawImage(poster, 0, 0, 150, 100)\n          ctx.draw()\n        }\n      })\n      // 这种方式获取canvas区域隐含的像素数据\n      wx.canvasGetImageData({\n        canvasId: 'myCanvas',\n        x: 0,\n        y: 0,\n        width: 150,\n        height: 100,\n        success(res) {\n          console.log(res.width) // 150\n          console.log(res.height) // 100\n          console.log(res.data instanceof Uint8ClampedArray) // true\n          console.log(res.data) // 150 * 100 * 4\n          console.log(res.data.length) // 150 * 100 * 4\n        }\n      })\n\t```\n\t```html\n\t<canvas id=\"myCanvas\" canvas-id=\"myCanvas\"></canvas>\n\t```\n- 运行截图![旧canvas](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzU4NTg5MzQ4MDc3Njk3OTA0OTRmZmIzOWRiNDdjMWRmNjk4ODQucG5n?x-oss-process=image/format,png)\n- 虽然两种方法，都能实现将网络图片绘制进canvas，但新版的进行了createImage，将其打印的话，其实就是新建了一个img标签，并将img标签的东西绘制进canvas\n\t- ![img console](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzFjMjE1NzMzZTRkY2UzNGZiNzI4NDFhZWEyMDc0ZWIwMjQ1OTQucG5n?x-oss-process=image/format,png)\n\t- 为什么微信官方会仅支持以下方式进行新版canvas2d 图片的绘制，考虑是什么？\n\t- ![经典报错](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2JhYWQ1OWRhNDI4M2FjZmViZTY1NGQ0ZWZiNTAxZDZlMjAxMjE2LnBuZw?x-oss-process=image/format,png)\n- 现在我们要将canvas的内容导成图片，同样分成新旧两版\n- 主要思路都是：在wxml中，如果canvas绘制图片没有完成，则显示canvas内容，绘制完成后，就利用canvasToTempFilePath，将图层内容生成指定大小图片，显示image\n\t- canvas2d \n\t\t```javascript\n\t\tconst that = this\n\t    const query = wx.createSelectorQuery().in(this)\n\t    query.select('#myCanvas')\n\t      .fields({ node: true, size: true })\n\t      .exec((res) => {\n\t        const canvas = res[0].node\n\t        const ctx = canvas.getContext('2d')\n\t        const img = canvas.createImage()\n\t        console.log('img', img)\n\t        img.onload = () => {\n\t          ctx.drawImage(img, 0, 0, 100, 100)\n\t            wx.canvasToTempFilePath({\n\t              x: 0,\n\t              y: 0,\n\t              width: 100,\n\t              height: 100,\n\t              destWidth: 100,\n\t              destHeight: 100,\n\t              canvas: canvas,\n\t              success(res) {\n\t                that.setData({\n\t                  imgPath: res.tempFilePath\n\t                })\n\t              },\n\t              fail(err) {\n\t                console.log('err', err)\n\t              }\n\t            })\n\t        }\n\t        img.src = 'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg'\n\t        // 这种方式获取canvas区域隐含的像素数据\n\t        console.log(ctx.getImageData(0, 0, 100, 100).data)\n\t      })\n\t\t```\n\t\t```html\n\t\t<canvas wx:if=\"{{!imgPath}}\" type=\"2d\" id=\"myCanvas\" canvas-id=\"myCanvas\" style=\"width: 330px;height: 340px;\"></canvas>\n\t\t<image wx:else src=\"{{imgPath}}\" style=\"width: 330px;height: 340px;\" />\n\t\t```\n\t\t- canvas2d 需要踩得坑是：它的官方文档🙃\n\t\t\t- ![canvas2d 转图片误导](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2UwM2Q1ZDg0YzYyNmI0NzlmZjBjOTlmNzA1YmRhYjg5NDc5MjcucG5n?x-oss-process=image/format,png)\n\t\t\t- 尝试下来，会\n\t\t\t\t- ![ctx.draw报错](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2UxMjRiY2Q3ZmNjYWI5ODBlNDdkMTk2YTMyZGQyODI4NDUzODcucG5n?x-oss-process=image/format,png)\n\t\t\t- 那我们可以继续往下看\n\t\t\t\t- ![canvas2d tempath正确实力](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2YxODk5NWFiNDY4N2IwYmZlYzhjZTZkZWU2ZWQxYmZjMTA1MTY1LnBuZw?x-oss-process=image/format,png)这才是符合我们需要\n\t\t- 运行截图\n\t\t\t- ![canvas2d运行截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2JmMzVlMzY4YzRjMmRhYTgxNTA0NzM0YTIxZGMxM2I2NDYwNzIucG5n?x-oss-process=image/format,png)\n\t- 旧版canvas\n\t\t```javascript\n\t    const ctx = wx.createCanvasContext('myCanvas')\n\t    const that = this\n\t    wx.getImageInfo({\n\t      src: 'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg',\n\t      success: function (res) {\n\t        console.log('res', res)\n\t        const poster = res.path\n\t        ctx.drawImage(poster, 0, 0, 150, 100)\n\t        ctx.draw(false, () => {\n\t          wx.canvasToTempFilePath({\n\t            x: 0,\n\t            y: 0,\n\t            width: 100,\n\t            height: 100,\n\t            destWidth: 100,\n\t            destHeight: 100,\n\t            canvasId: \"myCanvas\",\n\t            success(res) {\n\t              that.setData({\n\t                imgPath: res.tempFilePath\n\t              })\n\t              console.log(res.tempFilePath)\n\t            },\n\t            fail(err) {\n\t              console.log('err', err)\n\t            }\n\t          })\n\t        })\n\t        // 这种方式获取canvas区域隐含的像素数据\n\t        wx.canvasGetImageData({\n\t          canvasId: 'myCanvas',\n\t          x: 0,\n\t          y: 0,\n\t          width: 150,\n\t          height: 100,\n\t          success(res) {\n\t            console.log(res.width) // 150\n\t            console.log(res.height) // 100\n\t            console.log(res.data instanceof Uint8ClampedArray) // true\n\t            console.log(res.data) // 150 * 100 * 4\n\t            console.log(res.data.length) // 150 * 100 * 4\n\t          }\n\t        })\n\t      }\n\t    })\n\t\t```\n\t\t```html\n\t\t<canvas wx:if=\"{{!imgPath}}\" id=\"myCanvas\" canvas-id=\"myCanvas\" style=\"width: 330px;height: 340px;\"></canvas>\n\t\t<image wx:else src=\"{{imgPath}}\" style=\"width: 330px;height: 340px;\" />\n\t\t```\n\t\t- 运行截图\n\t\t\t- ![旧版canvas运行截图](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2EzZTRiYTBkYzc2NDgzYTM1NTYxZDcwNDUzNzZkNjZmNDU5MTgucG5n?x-oss-process=image/format,png)\n#### 写在后面\n- 感谢[Skady宝贝](https://github.com/skadieyes)在探讨问题中给予的帮助，欢迎大家去github找她玩👈\n- 祝大家多多发财\n----\n\t\t\n","slug":"微信小程序-fix canvas原生组件最顶层","published":1,"updated":"2020-04-06T05:47:48.882Z","comments":1,"photos":[],"link":"","_id":"ck8x6bg04000hzsp37brrhyl3","content":"<h4 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h4><ul>\n<li>大家应该都知道过，在微信小程序中，canvas等原生组件的层级是最高的，页面中无论你设置多大的z-index都无法覆盖在其之上，这就可能会产生一些问题</li>\n<li>就像这样<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2UxYmQ5OTM2M2VkYjU1NTRmYjc5MzBlZDllMTA0ZjEwMTc2MDM0LnBuZw?x-oss-process=image/format,png\" alt=\"canvas顶层问题截图\"></li>\n<li>柱状图是用canvas画的，它置于了我的tooltip之上。【这看起来真是一个可怕的问题<a id=\"more\"></a>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h4><ul>\n<li>微信官方提供了<a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html\" target=\"_blank\" rel=\"noopener\">cover-view</a>原生组件，覆盖在原生组件之上的文本视图</li>\n<li>微信官方提供了将canvas转化为图片的方式–<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.canvasToTempFilePath.html\" target=\"_blank\" rel=\"noopener\">wx.canvasToTempFilePath</a>，这样就可以”降级“</li>\n</ul>\n<h5 id=\"方法一：cover-view\"><a href=\"#方法一：cover-view\" class=\"headerlink\" title=\"方法一：cover-view\"></a>方法一：cover-view</h5><ul>\n<li>将tooltip用cover-view改写，效果如下<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2Y0MTZjZjhlMjNiZWEwMjNjYTM1M2JhOGExMDM1MDM2MzYyOTIucG5n?x-oss-process=image/format,png\" alt=\"cover-view version0.1 截图\"></li>\n<li>看上去，是解决了我们的问题，且tooltip后的灰色背景不能滑动了，【妈耶，好棒！</li>\n<li>但是，这产生了一个：<strong>当文本超出tooltip宽度时，scroll-y: auto，失效了，溢出部分被直接截取</strong></li>\n<li>罪魁祸首就是它<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2M5ZDljYjZiZTQ0ZGY3YmJmNmRlMjAxNDM1ZmYzOTJjNDMxNDMucG5n?x-oss-process=image/format,png\" alt=\"cover内置样式\"></li>\n</ul>\n</li>\n<li>那我们可以：<ul>\n<li>在tooltip分段内容中加上  <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.modal-layer-content-rule</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">white-space</span>: pre-wrap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在内容wrapper中加上  <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.modal-layer-content</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: scroll;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>完美解决<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2FhZjRkMDAyODdjZGI4M2Y0NWRhMGVkOTg3Mzc5MGNhNDQxMjkucG5n?x-oss-process=image/format,png\" alt=\"cover-view解决图\"><h5 id=\"方法二：wx-canvasToTempFilePath\"><a href=\"#方法二：wx-canvasToTempFilePath\" class=\"headerlink\" title=\"方法二：wx.canvasToTempFilePath\"></a>方法二：wx.canvasToTempFilePath</h5></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>首先我们要做的就是将网络图片绘制进canvas，官方关于canvas类型有两种<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2E4ZjJmNjA5OGYxNmQ4MzY3NWJiN2I3OWY0ZDM1NWM1MTAwMDg3LnBuZw?x-oss-process=image/format,png\" alt=\"两种canvas类型\"></li>\n<li>新canvas 2D接口尝试  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> query = wx.createSelectorQuery().in(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">   query.select(<span class=\"string\">'#myCanvas'</span>)</span><br><span class=\"line\">     .fields(&#123; <span class=\"attr\">node</span>: <span class=\"literal\">true</span>, <span class=\"attr\">size</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">     .exec(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">const</span> canvas = res[<span class=\"number\">0</span>].node</span><br><span class=\"line\">       <span class=\"keyword\">const</span> ctx = canvas.getContext(<span class=\"string\">'2d'</span>)</span><br><span class=\"line\">       <span class=\"keyword\">const</span> img = canvas.createImage()</span><br><span class=\"line\">       img.onload = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">         ctx.drawImage(img, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       img.src = <span class=\"string\">'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg'</span></span><br><span class=\"line\">       <span class=\"comment\">// 这种方式获取canvas区域隐含的像素数据</span></span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(ctx.getImageData(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">150</span>, <span class=\"number\">100</span>).data)</span><br><span class=\"line\">     &#125;)</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">type</span>=<span class=\"string\">\"2d\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myCanvas\"</span> <span class=\"attr\">canvas-id</span>=<span class=\"string\">\"myCanvas\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>运行截图<img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzE5ZWE3ZGYxYjg2ODUzOWFhNzVhY2E0OTAxYzI2MzU2OTk4NDYucG5n?x-oss-process=image/format,png\" alt=\"canvas2d 运行截图\"></li>\n<li>第二种旧canvas  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ctx = wx.createCanvasContext(<span class=\"string\">'myCanvas'</span>)</span><br><span class=\"line\">   wx.getImageInfo(&#123;</span><br><span class=\"line\">       src: <span class=\"string\">'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg'</span>,</span><br><span class=\"line\">       success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(<span class=\"string\">'res'</span>, res)</span><br><span class=\"line\">         <span class=\"keyword\">const</span> poster = res.path                                  </span><br><span class=\"line\">         ctx.drawImage(poster, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">150</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">         ctx.draw()</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">     <span class=\"comment\">// 这种方式获取canvas区域隐含的像素数据</span></span><br><span class=\"line\">     wx.canvasGetImageData(&#123;</span><br><span class=\"line\">       canvasId: <span class=\"string\">'myCanvas'</span>,</span><br><span class=\"line\">       x: <span class=\"number\">0</span>,</span><br><span class=\"line\">       y: <span class=\"number\">0</span>,</span><br><span class=\"line\">       width: <span class=\"number\">150</span>,</span><br><span class=\"line\">       height: <span class=\"number\">100</span>,</span><br><span class=\"line\">       success(res) &#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(res.width) <span class=\"comment\">// 150</span></span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(res.height) <span class=\"comment\">// 100</span></span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(res.data <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Uint8ClampedArray</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(res.data) <span class=\"comment\">// 150 * 100 * 4</span></span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(res.data.length) <span class=\"comment\">// 150 * 100 * 4</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;)</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myCanvas\"</span> <span class=\"attr\">canvas-id</span>=<span class=\"string\">\"myCanvas\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>运行截图<img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzU4NTg5MzQ4MDc3Njk3OTA0OTRmZmIzOWRiNDdjMWRmNjk4ODQucG5n?x-oss-process=image/format,png\" alt=\"旧canvas\"></li>\n<li>虽然两种方法，都能实现将网络图片绘制进canvas，但新版的进行了createImage，将其打印的话，其实就是新建了一个img标签，并将img标签的东西绘制进canvas<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzFjMjE1NzMzZTRkY2UzNGZiNzI4NDFhZWEyMDc0ZWIwMjQ1OTQucG5n?x-oss-process=image/format,png\" alt=\"img console\"></li>\n<li>为什么微信官方会仅支持以下方式进行新版canvas2d 图片的绘制，考虑是什么？</li>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2JhYWQ1OWRhNDI4M2FjZmViZTY1NGQ0ZWZiNTAxZDZlMjAxMjE2LnBuZw?x-oss-process=image/format,png\" alt=\"经典报错\"></li>\n</ul>\n</li>\n<li>现在我们要将canvas的内容导成图片，同样分成新旧两版</li>\n<li>主要思路都是：在wxml中，如果canvas绘制图片没有完成，则显示canvas内容，绘制完成后，就利用canvasToTempFilePath，将图层内容生成指定大小图片，显示image<ul>\n<li>canvas2d   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">   <span class=\"keyword\">const</span> query = wx.createSelectorQuery().in(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">   query.select(<span class=\"string\">'#myCanvas'</span>)</span><br><span class=\"line\">     .fields(&#123; <span class=\"attr\">node</span>: <span class=\"literal\">true</span>, <span class=\"attr\">size</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">     .exec(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">const</span> canvas = res[<span class=\"number\">0</span>].node</span><br><span class=\"line\">       <span class=\"keyword\">const</span> ctx = canvas.getContext(<span class=\"string\">'2d'</span>)</span><br><span class=\"line\">       <span class=\"keyword\">const</span> img = canvas.createImage()</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">'img'</span>, img)</span><br><span class=\"line\">       img.onload = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">         ctx.drawImage(img, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">           wx.canvasToTempFilePath(&#123;</span><br><span class=\"line\">             x: <span class=\"number\">0</span>,</span><br><span class=\"line\">             y: <span class=\"number\">0</span>,</span><br><span class=\"line\">             width: <span class=\"number\">100</span>,</span><br><span class=\"line\">             height: <span class=\"number\">100</span>,</span><br><span class=\"line\">             destWidth: <span class=\"number\">100</span>,</span><br><span class=\"line\">             destHeight: <span class=\"number\">100</span>,</span><br><span class=\"line\">             canvas: canvas,</span><br><span class=\"line\">             success(res) &#123;</span><br><span class=\"line\">               that.setData(&#123;</span><br><span class=\"line\">                 imgPath: res.tempFilePath</span><br><span class=\"line\">               &#125;)</span><br><span class=\"line\">             &#125;,</span><br><span class=\"line\">             fail(err) &#123;</span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(<span class=\"string\">'err'</span>, err)</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       img.src = <span class=\"string\">'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg'</span></span><br><span class=\"line\">       <span class=\"comment\">// 这种方式获取canvas区域隐含的像素数据</span></span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(ctx.getImageData(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>).data)</span><br><span class=\"line\">     &#125;)</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">wx:if</span>=<span class=\"string\">\"&#123;&#123;!imgPath&#125;&#125;\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"2d\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myCanvas\"</span> <span class=\"attr\">canvas-id</span>=<span class=\"string\">\"myCanvas\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 330px;height: 340px;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">image</span> <span class=\"attr\">wx:else</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;&#123;imgPath&#125;&#125;\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 330px;height: 340px;\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>canvas2d 需要踩得坑是：它的官方文档🙃<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2UwM2Q1ZDg0YzYyNmI0NzlmZjBjOTlmNzA1YmRhYjg5NDc5MjcucG5n?x-oss-process=image/format,png\" alt=\"canvas2d 转图片误导\"></li>\n<li>尝试下来，会<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2UxMjRiY2Q3ZmNjYWI5ODBlNDdkMTk2YTMyZGQyODI4NDUzODcucG5n?x-oss-process=image/format,png\" alt=\"ctx.draw报错\"></li>\n</ul>\n</li>\n<li>那我们可以继续往下看<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2YxODk5NWFiNDY4N2IwYmZlYzhjZTZkZWU2ZWQxYmZjMTA1MTY1LnBuZw?x-oss-process=image/format,png\" alt=\"canvas2d tempath正确实力\">这才是符合我们需要</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>运行截图<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2JmMzVlMzY4YzRjMmRhYTgxNTA0NzM0YTIxZGMxM2I2NDYwNzIucG5n?x-oss-process=image/format,png\" alt=\"canvas2d运行截图\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>旧版canvas  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ctx = wx.createCanvasContext(<span class=\"string\">'myCanvas'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">wx.getImageInfo(&#123;</span><br><span class=\"line\">  src: <span class=\"string\">'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg'</span>,</span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'res'</span>, res)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> poster = res.path</span><br><span class=\"line\">    ctx.drawImage(poster, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">150</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">    ctx.draw(<span class=\"literal\">false</span>, () =&gt; &#123;</span><br><span class=\"line\">      wx.canvasToTempFilePath(&#123;</span><br><span class=\"line\">        x: <span class=\"number\">0</span>,</span><br><span class=\"line\">        y: <span class=\"number\">0</span>,</span><br><span class=\"line\">        width: <span class=\"number\">100</span>,</span><br><span class=\"line\">        height: <span class=\"number\">100</span>,</span><br><span class=\"line\">        destWidth: <span class=\"number\">100</span>,</span><br><span class=\"line\">        destHeight: <span class=\"number\">100</span>,</span><br><span class=\"line\">        canvasId: <span class=\"string\">\"myCanvas\"</span>,</span><br><span class=\"line\">        success(res) &#123;</span><br><span class=\"line\">          that.setData(&#123;</span><br><span class=\"line\">            imgPath: res.tempFilePath</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(res.tempFilePath)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        fail(err) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'err'</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 这种方式获取canvas区域隐含的像素数据</span></span><br><span class=\"line\">    wx.canvasGetImageData(&#123;</span><br><span class=\"line\">      canvasId: <span class=\"string\">'myCanvas'</span>,</span><br><span class=\"line\">      x: <span class=\"number\">0</span>,</span><br><span class=\"line\">      y: <span class=\"number\">0</span>,</span><br><span class=\"line\">      width: <span class=\"number\">150</span>,</span><br><span class=\"line\">      height: <span class=\"number\">100</span>,</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res.width) <span class=\"comment\">// 150</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res.height) <span class=\"comment\">// 100</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res.data <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Uint8ClampedArray</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res.data) <span class=\"comment\">// 150 * 100 * 4</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res.data.length) <span class=\"comment\">// 150 * 100 * 4</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">wx:if</span>=<span class=\"string\">\"&#123;&#123;!imgPath&#125;&#125;\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myCanvas\"</span> <span class=\"attr\">canvas-id</span>=<span class=\"string\">\"myCanvas\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 330px;height: 340px;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">image</span> <span class=\"attr\">wx:else</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;&#123;imgPath&#125;&#125;\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 330px;height: 340px;\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行截图<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2EzZTRiYTBkYzc2NDgzYTM1NTYxZDcwNDUzNzZkNjZmNDU5MTgucG5n?x-oss-process=image/format,png\" alt=\"旧版canvas运行截图\"><h4 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h4></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>感谢<a href=\"https://github.com/skadieyes\" target=\"_blank\" rel=\"noopener\">Skady宝贝</a>在探讨问题中给予的帮助，欢迎大家去github找她玩👈</li>\n<li>祝大家多多发财</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"<h4 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h4><ul>\n<li>大家应该都知道过，在微信小程序中，canvas等原生组件的层级是最高的，页面中无论你设置多大的z-index都无法覆盖在其之上，这就可能会产生一些问题</li>\n<li>就像这样<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2UxYmQ5OTM2M2VkYjU1NTRmYjc5MzBlZDllMTA0ZjEwMTc2MDM0LnBuZw?x-oss-process=image/format,png\" alt=\"canvas顶层问题截图\"></li>\n<li>柱状图是用canvas画的，它置于了我的tooltip之上。【这看起来真是一个可怕的问题","more":"</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h4><ul>\n<li>微信官方提供了<a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html\" target=\"_blank\" rel=\"noopener\">cover-view</a>原生组件，覆盖在原生组件之上的文本视图</li>\n<li>微信官方提供了将canvas转化为图片的方式–<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.canvasToTempFilePath.html\" target=\"_blank\" rel=\"noopener\">wx.canvasToTempFilePath</a>，这样就可以”降级“</li>\n</ul>\n<h5 id=\"方法一：cover-view\"><a href=\"#方法一：cover-view\" class=\"headerlink\" title=\"方法一：cover-view\"></a>方法一：cover-view</h5><ul>\n<li>将tooltip用cover-view改写，效果如下<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2Y0MTZjZjhlMjNiZWEwMjNjYTM1M2JhOGExMDM1MDM2MzYyOTIucG5n?x-oss-process=image/format,png\" alt=\"cover-view version0.1 截图\"></li>\n<li>看上去，是解决了我们的问题，且tooltip后的灰色背景不能滑动了，【妈耶，好棒！</li>\n<li>但是，这产生了一个：<strong>当文本超出tooltip宽度时，scroll-y: auto，失效了，溢出部分被直接截取</strong></li>\n<li>罪魁祸首就是它<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2M5ZDljYjZiZTQ0ZGY3YmJmNmRlMjAxNDM1ZmYzOTJjNDMxNDMucG5n?x-oss-process=image/format,png\" alt=\"cover内置样式\"></li>\n</ul>\n</li>\n<li>那我们可以：<ul>\n<li>在tooltip分段内容中加上  <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.modal-layer-content-rule</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">white-space</span>: pre-wrap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在内容wrapper中加上  <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.modal-layer-content</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: scroll;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>完美解决<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2FhZjRkMDAyODdjZGI4M2Y0NWRhMGVkOTg3Mzc5MGNhNDQxMjkucG5n?x-oss-process=image/format,png\" alt=\"cover-view解决图\"><h5 id=\"方法二：wx-canvasToTempFilePath\"><a href=\"#方法二：wx-canvasToTempFilePath\" class=\"headerlink\" title=\"方法二：wx.canvasToTempFilePath\"></a>方法二：wx.canvasToTempFilePath</h5></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>首先我们要做的就是将网络图片绘制进canvas，官方关于canvas类型有两种<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2E4ZjJmNjA5OGYxNmQ4MzY3NWJiN2I3OWY0ZDM1NWM1MTAwMDg3LnBuZw?x-oss-process=image/format,png\" alt=\"两种canvas类型\"></li>\n<li>新canvas 2D接口尝试  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> query = wx.createSelectorQuery().in(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">   query.select(<span class=\"string\">'#myCanvas'</span>)</span><br><span class=\"line\">     .fields(&#123; <span class=\"attr\">node</span>: <span class=\"literal\">true</span>, <span class=\"attr\">size</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">     .exec(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">const</span> canvas = res[<span class=\"number\">0</span>].node</span><br><span class=\"line\">       <span class=\"keyword\">const</span> ctx = canvas.getContext(<span class=\"string\">'2d'</span>)</span><br><span class=\"line\">       <span class=\"keyword\">const</span> img = canvas.createImage()</span><br><span class=\"line\">       img.onload = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">         ctx.drawImage(img, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       img.src = <span class=\"string\">'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg'</span></span><br><span class=\"line\">       <span class=\"comment\">// 这种方式获取canvas区域隐含的像素数据</span></span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(ctx.getImageData(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">150</span>, <span class=\"number\">100</span>).data)</span><br><span class=\"line\">     &#125;)</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">type</span>=<span class=\"string\">\"2d\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myCanvas\"</span> <span class=\"attr\">canvas-id</span>=<span class=\"string\">\"myCanvas\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>运行截图<img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzE5ZWE3ZGYxYjg2ODUzOWFhNzVhY2E0OTAxYzI2MzU2OTk4NDYucG5n?x-oss-process=image/format,png\" alt=\"canvas2d 运行截图\"></li>\n<li>第二种旧canvas  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ctx = wx.createCanvasContext(<span class=\"string\">'myCanvas'</span>)</span><br><span class=\"line\">   wx.getImageInfo(&#123;</span><br><span class=\"line\">       src: <span class=\"string\">'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg'</span>,</span><br><span class=\"line\">       success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(<span class=\"string\">'res'</span>, res)</span><br><span class=\"line\">         <span class=\"keyword\">const</span> poster = res.path                                  </span><br><span class=\"line\">         ctx.drawImage(poster, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">150</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">         ctx.draw()</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">     <span class=\"comment\">// 这种方式获取canvas区域隐含的像素数据</span></span><br><span class=\"line\">     wx.canvasGetImageData(&#123;</span><br><span class=\"line\">       canvasId: <span class=\"string\">'myCanvas'</span>,</span><br><span class=\"line\">       x: <span class=\"number\">0</span>,</span><br><span class=\"line\">       y: <span class=\"number\">0</span>,</span><br><span class=\"line\">       width: <span class=\"number\">150</span>,</span><br><span class=\"line\">       height: <span class=\"number\">100</span>,</span><br><span class=\"line\">       success(res) &#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(res.width) <span class=\"comment\">// 150</span></span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(res.height) <span class=\"comment\">// 100</span></span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(res.data <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Uint8ClampedArray</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(res.data) <span class=\"comment\">// 150 * 100 * 4</span></span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(res.data.length) <span class=\"comment\">// 150 * 100 * 4</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;)</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myCanvas\"</span> <span class=\"attr\">canvas-id</span>=<span class=\"string\">\"myCanvas\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>运行截图<img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzU4NTg5MzQ4MDc3Njk3OTA0OTRmZmIzOWRiNDdjMWRmNjk4ODQucG5n?x-oss-process=image/format,png\" alt=\"旧canvas\"></li>\n<li>虽然两种方法，都能实现将网络图片绘制进canvas，但新版的进行了createImage，将其打印的话，其实就是新建了一个img标签，并将img标签的东西绘制进canvas<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzFjMjE1NzMzZTRkY2UzNGZiNzI4NDFhZWEyMDc0ZWIwMjQ1OTQucG5n?x-oss-process=image/format,png\" alt=\"img console\"></li>\n<li>为什么微信官方会仅支持以下方式进行新版canvas2d 图片的绘制，考虑是什么？</li>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2JhYWQ1OWRhNDI4M2FjZmViZTY1NGQ0ZWZiNTAxZDZlMjAxMjE2LnBuZw?x-oss-process=image/format,png\" alt=\"经典报错\"></li>\n</ul>\n</li>\n<li>现在我们要将canvas的内容导成图片，同样分成新旧两版</li>\n<li>主要思路都是：在wxml中，如果canvas绘制图片没有完成，则显示canvas内容，绘制完成后，就利用canvasToTempFilePath，将图层内容生成指定大小图片，显示image<ul>\n<li>canvas2d   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">   <span class=\"keyword\">const</span> query = wx.createSelectorQuery().in(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">   query.select(<span class=\"string\">'#myCanvas'</span>)</span><br><span class=\"line\">     .fields(&#123; <span class=\"attr\">node</span>: <span class=\"literal\">true</span>, <span class=\"attr\">size</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">     .exec(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">const</span> canvas = res[<span class=\"number\">0</span>].node</span><br><span class=\"line\">       <span class=\"keyword\">const</span> ctx = canvas.getContext(<span class=\"string\">'2d'</span>)</span><br><span class=\"line\">       <span class=\"keyword\">const</span> img = canvas.createImage()</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">'img'</span>, img)</span><br><span class=\"line\">       img.onload = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">         ctx.drawImage(img, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">           wx.canvasToTempFilePath(&#123;</span><br><span class=\"line\">             x: <span class=\"number\">0</span>,</span><br><span class=\"line\">             y: <span class=\"number\">0</span>,</span><br><span class=\"line\">             width: <span class=\"number\">100</span>,</span><br><span class=\"line\">             height: <span class=\"number\">100</span>,</span><br><span class=\"line\">             destWidth: <span class=\"number\">100</span>,</span><br><span class=\"line\">             destHeight: <span class=\"number\">100</span>,</span><br><span class=\"line\">             canvas: canvas,</span><br><span class=\"line\">             success(res) &#123;</span><br><span class=\"line\">               that.setData(&#123;</span><br><span class=\"line\">                 imgPath: res.tempFilePath</span><br><span class=\"line\">               &#125;)</span><br><span class=\"line\">             &#125;,</span><br><span class=\"line\">             fail(err) &#123;</span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(<span class=\"string\">'err'</span>, err)</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       img.src = <span class=\"string\">'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg'</span></span><br><span class=\"line\">       <span class=\"comment\">// 这种方式获取canvas区域隐含的像素数据</span></span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(ctx.getImageData(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>).data)</span><br><span class=\"line\">     &#125;)</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">wx:if</span>=<span class=\"string\">\"&#123;&#123;!imgPath&#125;&#125;\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"2d\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myCanvas\"</span> <span class=\"attr\">canvas-id</span>=<span class=\"string\">\"myCanvas\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 330px;height: 340px;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">image</span> <span class=\"attr\">wx:else</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;&#123;imgPath&#125;&#125;\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 330px;height: 340px;\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>canvas2d 需要踩得坑是：它的官方文档🙃<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2UwM2Q1ZDg0YzYyNmI0NzlmZjBjOTlmNzA1YmRhYjg5NDc5MjcucG5n?x-oss-process=image/format,png\" alt=\"canvas2d 转图片误导\"></li>\n<li>尝试下来，会<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2UxMjRiY2Q3ZmNjYWI5ODBlNDdkMTk2YTMyZGQyODI4NDUzODcucG5n?x-oss-process=image/format,png\" alt=\"ctx.draw报错\"></li>\n</ul>\n</li>\n<li>那我们可以继续往下看<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2YxODk5NWFiNDY4N2IwYmZlYzhjZTZkZWU2ZWQxYmZjMTA1MTY1LnBuZw?x-oss-process=image/format,png\" alt=\"canvas2d tempath正确实力\">这才是符合我们需要</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>运行截图<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AxLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2JmMzVlMzY4YzRjMmRhYTgxNTA0NzM0YTIxZGMxM2I2NDYwNzIucG5n?x-oss-process=image/format,png\" alt=\"canvas2d运行截图\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>旧版canvas  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ctx = wx.createCanvasContext(<span class=\"string\">'myCanvas'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">wx.getImageInfo(&#123;</span><br><span class=\"line\">  src: <span class=\"string\">'https://p0.meituan.net/myvideodistribute/0990cc2062e81ab6cc11fd8690f8755042005.jpg'</span>,</span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'res'</span>, res)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> poster = res.path</span><br><span class=\"line\">    ctx.drawImage(poster, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">150</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">    ctx.draw(<span class=\"literal\">false</span>, () =&gt; &#123;</span><br><span class=\"line\">      wx.canvasToTempFilePath(&#123;</span><br><span class=\"line\">        x: <span class=\"number\">0</span>,</span><br><span class=\"line\">        y: <span class=\"number\">0</span>,</span><br><span class=\"line\">        width: <span class=\"number\">100</span>,</span><br><span class=\"line\">        height: <span class=\"number\">100</span>,</span><br><span class=\"line\">        destWidth: <span class=\"number\">100</span>,</span><br><span class=\"line\">        destHeight: <span class=\"number\">100</span>,</span><br><span class=\"line\">        canvasId: <span class=\"string\">\"myCanvas\"</span>,</span><br><span class=\"line\">        success(res) &#123;</span><br><span class=\"line\">          that.setData(&#123;</span><br><span class=\"line\">            imgPath: res.tempFilePath</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(res.tempFilePath)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        fail(err) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'err'</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 这种方式获取canvas区域隐含的像素数据</span></span><br><span class=\"line\">    wx.canvasGetImageData(&#123;</span><br><span class=\"line\">      canvasId: <span class=\"string\">'myCanvas'</span>,</span><br><span class=\"line\">      x: <span class=\"number\">0</span>,</span><br><span class=\"line\">      y: <span class=\"number\">0</span>,</span><br><span class=\"line\">      width: <span class=\"number\">150</span>,</span><br><span class=\"line\">      height: <span class=\"number\">100</span>,</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res.width) <span class=\"comment\">// 150</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res.height) <span class=\"comment\">// 100</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res.data <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Uint8ClampedArray</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res.data) <span class=\"comment\">// 150 * 100 * 4</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res.data.length) <span class=\"comment\">// 150 * 100 * 4</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">wx:if</span>=<span class=\"string\">\"&#123;&#123;!imgPath&#125;&#125;\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myCanvas\"</span> <span class=\"attr\">canvas-id</span>=<span class=\"string\">\"myCanvas\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 330px;height: 340px;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">image</span> <span class=\"attr\">wx:else</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;&#123;imgPath&#125;&#125;\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 330px;height: 340px;\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行截图<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2EzZTRiYTBkYzc2NDgzYTM1NTYxZDcwNDUzNzZkNjZmNDU5MTgucG5n?x-oss-process=image/format,png\" alt=\"旧版canvas运行截图\"><h4 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h4></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>感谢<a href=\"https://github.com/skadieyes\" target=\"_blank\" rel=\"noopener\">Skady宝贝</a>在探讨问题中给予的帮助，欢迎大家去github找她玩👈</li>\n<li>祝大家多多发财</li>\n</ul>\n<hr>"},{"title":"微信小程序-获取图片主色调","date":"2020-04-05T04:06:48.000Z","description":["是的我要开始做：根据图片的主色调来改变一下页面背景颜色了🙆","记录一下，自己碰到的问题以及思考","时间多的话，会考虑将代码发在github，欢迎大家去star😘 - 理一下思路 1. 将网络图片绘制进canvas 2. 通过canvas的getImageData获取图片的像素数据 -  [canvas 2d 与旧版 canvas 将网络图片绘制进canvas的两种方法实践](https://blog.csdn.net/Elle_Peng/article/details/105030971) 3. 分析目前主要用于获取图片主色调的算法，并实践 4. 得到主要色调，再将rgb转换成hsb，并对b值，进行修改，制作渐变，左侧35，右侧15"],"_content":"\n#### 写在前面\n- 是的我要开始做：根据图片的主色调来改变一下页面背景颜色了🙆\n- 记录一下，自己碰到的问题以及思考\n- 时间多的话，会考虑将代码发在github，欢迎大家去star😘\n---\n\n#### 开发准备\n - 理一下思路\n\t1. 将网络图片绘制进canvas\n\t2. 通过canvas的getImageData获取图片的像素数据\n\t\t-  [canvas 2d 与旧版 canvas 将网络图片绘制进canvas的两种方法实践](https://blog.csdn.net/Elle_Peng/article/details/105030971)\n\t3. 分析目前主要用于获取图片主色调的算法，并实践\n\t4. 得到主要色调，再将rgb转换成hsb，并对b值，进行修改，制作渐变，左侧35，右侧15\n<!-- more -->\n- 嗯，祝我成功\n#### 颜色空间基础知识背景+减色算法\n- [颜色空间 RGB CMY HSV HSL LAB](http://www.360doc.com/content/17/0417/19/41797635_646363886.shtml)\n- 图片颜色量化算法\n\t- 比较常见的应用就是用于提取图片的主色调用于上色配色,当然也可以用于图像分割\n\t- 主流算法\n\t\t- 两个大方向\n\t\t- **在颜色空间合理地选取采样点来构造颜色表，使得减色后的图像和原图尽可能地接近**\n\t\t\t- 直接量化\n\t\t\t\t- 对每个颜色通道单独重新采样，将每个通道的色阶从256减少到某个指定的数字。这样得到一个新的小的多的颜色空间，而原图像中的每一个像素将被用在新的颜色空间中的最近邻取代\n\t\t\t- 统计量化\n\t\t\t\t- 核心：调整直方图使得累积分布曲线呈线性，从而使图像像素点的亮度值尽可能均匀地分布\n\t\t\t\t- 利用原图的直方图来引导采样点的选取，使得每个采样点可以大致覆盖相同数量的像素点\n\t\t\t\t- 对每个颜色通道建立直方图，然后根据这些直方图对各个颜色通道单独采样，在像素值分布多的区域进行密集采样，别的区域稀疏采样，再利用这些采样点来组合成最终的颜色表，原图中的每个像素点用颜色表中最接近的颜色替换掉\n\t\t\t- 颜色空间分割(Median-Cut)\n\t\t\t\t- 核心：在颜色空间建立一棵二叉树，通过不断地细化这棵树来近似得到一个颜色三维直方图，然后再根据这棵树来分配采样点\n\t\t\t\t- 基于图像颜色样本分布的自适应方法，不论图像中颜色样本的分布如何，总是可以生成一个和颜色样本分布匹配良好的颜色表：在颜色样本分布密集的区域内采样点分布也相对密集，其他区域则分配了较少的采样点。且相同数目的颜色样本总是用同样数量的采样点来代表，所以颜色样本分布密集的区域，采样点的数量自然就会多，反之则相应的比较少\n\t\t\t\t- 最重要、应用最广泛的减色算法之一\n\t\t\t- k均值聚类(k-Means clustering)\n\t\t\t\t- 核心：将像素按颜色的相似程度归类\n\t\t- **从一个初始的颜色表出发，通过不断修改颜色表来改善减色效果**\n\t\t\t- 神经网络方法(ANN)\n\t\t\t\t- 颜色表通过神经元来编码，通过缓慢的调节神经元的颜色值以保证整个神经网络逐步收敛于最小误差状态（即通过神经网络产生的图像和原图之间误差最小）\n#### 直接量化实践\n- 首先我们可以来看一看getImageData后的数据\n\t- ![getImageData数据](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzljZjVjMjQzMDI0NmE0YjE0YzFlYmMzMjYwZDkwYTgwNTQzMDIucG5n?x-oss-process=image/format,png)\n\t- 可以简单看作是外层循环为rgba的打平了二维数组\n- 如果按满足需求做，只要一个主色调的话，可以把整个getImageData获得的数据，进行各个通道的平均值求值，再拼接，像这样\n\t```javascript\n\tgetUniqueColor(imageData) {\n    let res_r = 0\n    let res_g = 0\n    let res_b = 0\n    let res_a = 0\n    for (let i = 0; i < imageData.length; i += 1) {\n      if (i % 4 === 0) {\n        res_r += imageData[i]\n      } else if (i % 4 === 1) {\n        res_g += imageData[i]\n      } else if (i % 4 === 2) {\n        res_b += imageData[i]\n      } else if (i % 4 === 3) {\n        res_a += imageData[i]\n      } \n    }\n    res_r = Math.round(res_r / (imageData.length / 4))\n    res_g =  Math.round(res_g / (imageData.length / 4))\n    res_b =  Math.round(res_b / (imageData.length / 4))\n    res_a =  Math.round(res_a / (imageData.length / 4))\n    console.log('res_r', res_r)\n    console.log('res_g', res_g)\n    console.log('res_b', res_b)\n    console.log('res_a', res_a)\n  },\n\t```\n\t- 运行截图\n\t\t- ![暴力法求主色调](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzc4NzFiOTVmYzA4NWQ3NGQwNDc4OWY0ZWI5Yzc0YThmNzQ5OTYucG5n?x-oss-process=image/format,png)\n\t\t- 无相关点越多，误差越大👎\n- 我们可以“对每个颜色通道单独重新采样，将每个通道的色阶从256减少到某个指定的数字。这样得到一个新的小的多的颜色空间，而原图像中的每一个像素将被用在新的颜色空间中的最近邻取代”\n\t```javascript\n\tconst COLOR_SIZE = 40 // 单位色块的大小（像素个数，默认40）。以单位色块的平均像素值为作为统计单位\n\tconst LEVEL = 32 // 色深，颜色分区参数（0-255），总256，2^8，即8bit，4个通道（rgba），即默认色深4*8bit，32bit\n\t// 分区块，可以拓展性的求主要色板，用来做palette\n    const mapData = that.getLevelData(imageData);\n    const colors = that.getMostColor(mapData);\n    if (!colors) {\n      return\n    } else {\n      const color = that.getAverageColor(colors)\n      console.log('color', color)\n    }\n\t```\n\t- 将getImageData数据分成特定大小的区块，分别算出各个区块的averageColor，再利用map特性，将averageColor作key，count各个averageColor个数\n\t\t```javascript\n\t\t  // 获取每段的颜色数据\n\t\t  // 根据像素数据，按单位色块进行切割\n\t\t  getLevelData(imageData) {\n\t\t    const len = imageData.length;\n\t\t    const mapData = {};\n\t\t    for (let i = 0; i < len; i += COLOR_SIZE * 4) {\n\t\t      const blockColor = this.getBlockColor(imageData, i); // 该区块平均rgba [{r,g,b,a}]数据\n\t\t      // 获取各个区块的平均rgba数据，将各个通道的颜色进行LEVEL色深降级\n\t\t      // 根据r_g_b_a 建立map索引\n\t\t      const key = this.getColorLevel(blockColor);\n\t\t      !mapData[key] && (mapData[key] = []);\n\t\t      mapData[key].push(blockColor);\n\t\t    }\n\t\t    return mapData;\n\t\t  },\n\t\t\n\t\t  // 获取单位块的全部色值\n\t\t  // 并根据全部色值，计算平均色值\n\t\t  // 处理最后边界值，小于COLOR_SIZE\n\t\t  getBlockColor(imageData, start) {\n\t\t    let data = [],\n\t\t      count = COLOR_SIZE,\n\t\t      len = COLOR_SIZE * 4;\n\t\t    imageData.length <= start + len && (count = Math.floor((imageData.length - start - 1) / 4));\n\t\t    for (let i = 0; i < count; i += 4) {\n\t\t      data.push({\n\t\t        r: imageData[start + i + 0],\n\t\t        g: imageData[start + i + 1],\n\t\t        b: imageData[start + i + 2],\n\t\t        a: imageData[start + i + 3]\n\t\t      })\n\t\t    }\n\t\t    return this.getAverageColor(data);\n\t\t  },\n\t\t\n\t\t  // 取出各个通道的平均值，即为改色块的平均色值\n\t\t  getAverageColor(colorArr) {\n\t\t    const len = colorArr.length;\n\t\t    let sr = 0, sg = 0, sb = 0, sa = 0;\n\t\t    colorArr.map(function (item) {\n\t\t      sr += item.r;\n\t\t      sg += item.g;\n\t\t      sb += item.b;\n\t\t      sa += item.a;\n\t\t    });\n\t\t    return {\n\t\t      r: Math.round(sr / len),\n\t\t      g: Math.round(sg / len),\n\t\t      b: Math.round(sb / len),\n\t\t      a: Math.round(sa / len)\n\t\t    }\n\t\t  },\n\t\t\n\t\t  getColorLevel(color) {\n\t\t    return this.getLevel(color.r) + '_' + this.getLevel(color.g) + '_' + this.getLevel(color.b) + '_' + this.getLevel(color.a)\n\t\t  },\n\t\t\n\t\t  // 色深降级\n\t\t  getLevel(value) {\n\t\t    return Math.round(value / LEVEL)\n\t\t  },\n\t\t```\n\t- 把出现次数最多的averageColor区块，作为采样区块，再获取一遍averageColor，即是最终主色调\n\t\t```javascript\n\t\t  // 根据色块颜色，获取\n\t\t  getMostColor(colorData) {\n\t\t    let rst = null, len = 0;\n\t\t    for (let key in colorData) {\n\t\t      console.log('colorData[key].length', colorData[key].length)\n\t\t      console.log('colorData[key].length', colorData[key])\n\t\t      console.log('colorData[key].length', key)\n\t\t      colorData[key].length > len && (\n\t\t        rst = colorData[key],\n\t\t        len = colorData[key].length\n\t\t      )\n\t\t    }\n\t\t    return rst;\n\t\t  },\n\t\t```\n\t- 运行截图\n\t\t- ![区块获取主色调](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2ViYzI3MmNkNzU2NjNhODUxYmM2MWQ0MDE4OWJjZGI3NzQ5NDUucG5n?x-oss-process=image/format,png)\n\t\t- 颜色可信度提高了很多\n#### 拓展实践-医学灰色影像\n- 核心：将**三通道转成单通道**即可\n\t```javascript\n\tlet greyImageData = that.greyTheImage(imageData)\n    wx.canvasPutImageData({\n      canvasId: 'myCanvas',\n      x: 150,\n      y: 0,\n      width: 150,\n      height: 100,\n      data: greyImageData,\n      success (res) {\n        console.log('canvasPutImageData it worked!')\n      }\n    })\n\n  greyTheImage(imageData) {\n      // imageData有4个通道rgba\n      for (let i = 0; i < imageData.length; i += 4) {\n        let sum_rgb = 0\n        // 但我们只需要rgb三通道，a-alpha通道无用\n        for (let j = 0; j < 3; j += 1) {\n          sum_rgb = sum_rgb + imageData[i + j]\n        }\n        let grey = Math.round(sum_rgb / 3)\n        imageData[i] = grey\n        imageData[i + 1] = grey\n        imageData[i + 2] = grey\n      }\n      return imageData\n  },\n\t```\n- 运行截图\n![医学灰色影像](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzhmNWJhNzk2OTJjOWEwOTA2MDNlMzkxMzBlMDRiZTY4MTAwNzcwLnBuZw?x-oss-process=image/format,png)\n\n#### 格式化rgba输出\n- 像这样![格式化rgba输出](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2YxNDVhYzM4YzQ1MjFkNDgzNGNkZGQ5NTNmNjQ1MWQ3NTI0NTkucG5n?x-oss-process=image/format,png)\n\t```javascript\n\t  // 对最终颜色的字符串格式化\n\t  /**\n\t   * result:{\n\t   *   hex:'#ffffff',            十六位值\n\t   *   hexa:'#ffffff00',         十六位值带alpha值\n\t   *   rgb:'rgb(0,0,0)',         RGB值\n\t   *   rgba:'rgba(0,0,0,0)'      RGB值带alpha值\n\t   * }\n\t   */\n\t\n\t  colorStrFormat(color) {\n\t    const rgba = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + (color.a / 255).toFixed(4).replace(/\\.*0+$/, '') + ')';\n\t    const rgb = 'rgb(' + color.r + ',' + color.g + ',' + color.b + ')';\n\t    const hex = '#' + this.Num2Hex(color.r) + this.Num2Hex(color.g) + this.Num2Hex(color.b);\n\t    const hexa = hex + this.Num2Hex(color.a);\n\t    return {\n\t      rgba: rgba,\n\t      rgb: rgb,\n\t      hex: hex,\n\t      hexa: hexa\n\t    }\n\t  },\n\t\n\t  Num2Hex(num) {\n\t    const hex = num.toString(16) + '';\n\t    if (hex.length < 2) {\n\t      return '0' + hex;\n\t    } else {\n\t      return hex;\n\t    }\n\t  },\n\t```\n#### 参考文献\n- [phg1024 JavaScript图像处理(6) - 减色算法(Color Reduction)](https://blog.csdn.net/u012843346/article/details/16839649)\n- [获取图片主色调的插件](https://github.com/whoiam2007s/ImgMainColor)\n- 其实也可以利用 [CSS新特性去改变背景颜色](https://blog.csdn.net/nanhupatar/article/details/82793637)，比如高斯模糊等来达到业务需求\n#### 写在后面\n- 周六听了一天 John Lennon 歌曲【这也是我拖更的原因😶 羡慕他和 Yoko 那段伊甸园般的爱情，他对 Yoko 的痴爱，他和母亲的两次分别感同身受，Beatles在一起做音乐的欢乐，他对 Sean 的宠溺父爱，但他的人生却在一次枪杀后戛然而止，心痛 心痛 🌧\n- 祝大家多多发财\n---\n","source":"_posts/微信小程序-获取图片主色调.md","raw":"---\ntitle: 微信小程序-获取图片主色调\ndate: 2020-04-05 12:06:48\ntags: \n- 微信小程序\ncategories:\n- 微信小程序\ndescription:\n- 是的我要开始做：根据图片的主色调来改变一下页面背景颜色了🙆\n- 记录一下，自己碰到的问题以及思考\n- 时间多的话，会考虑将代码发在github，欢迎大家去star😘\n  - 理一下思路\n    1. 将网络图片绘制进canvas\n    2. 通过canvas的getImageData获取图片的像素数据\n      -  [canvas 2d 与旧版 canvas 将网络图片绘制进canvas的两种方法实践](https://blog.csdn.net/Elle_Peng/article/details/105030971)\n    3. 分析目前主要用于获取图片主色调的算法，并实践\n    4. 得到主要色调，再将rgb转换成hsb，并对b值，进行修改，制作渐变，左侧35，右侧15\n\n\n---\n\n#### 写在前面\n- 是的我要开始做：根据图片的主色调来改变一下页面背景颜色了🙆\n- 记录一下，自己碰到的问题以及思考\n- 时间多的话，会考虑将代码发在github，欢迎大家去star😘\n---\n\n#### 开发准备\n - 理一下思路\n\t1. 将网络图片绘制进canvas\n\t2. 通过canvas的getImageData获取图片的像素数据\n\t\t-  [canvas 2d 与旧版 canvas 将网络图片绘制进canvas的两种方法实践](https://blog.csdn.net/Elle_Peng/article/details/105030971)\n\t3. 分析目前主要用于获取图片主色调的算法，并实践\n\t4. 得到主要色调，再将rgb转换成hsb，并对b值，进行修改，制作渐变，左侧35，右侧15\n<!-- more -->\n- 嗯，祝我成功\n#### 颜色空间基础知识背景+减色算法\n- [颜色空间 RGB CMY HSV HSL LAB](http://www.360doc.com/content/17/0417/19/41797635_646363886.shtml)\n- 图片颜色量化算法\n\t- 比较常见的应用就是用于提取图片的主色调用于上色配色,当然也可以用于图像分割\n\t- 主流算法\n\t\t- 两个大方向\n\t\t- **在颜色空间合理地选取采样点来构造颜色表，使得减色后的图像和原图尽可能地接近**\n\t\t\t- 直接量化\n\t\t\t\t- 对每个颜色通道单独重新采样，将每个通道的色阶从256减少到某个指定的数字。这样得到一个新的小的多的颜色空间，而原图像中的每一个像素将被用在新的颜色空间中的最近邻取代\n\t\t\t- 统计量化\n\t\t\t\t- 核心：调整直方图使得累积分布曲线呈线性，从而使图像像素点的亮度值尽可能均匀地分布\n\t\t\t\t- 利用原图的直方图来引导采样点的选取，使得每个采样点可以大致覆盖相同数量的像素点\n\t\t\t\t- 对每个颜色通道建立直方图，然后根据这些直方图对各个颜色通道单独采样，在像素值分布多的区域进行密集采样，别的区域稀疏采样，再利用这些采样点来组合成最终的颜色表，原图中的每个像素点用颜色表中最接近的颜色替换掉\n\t\t\t- 颜色空间分割(Median-Cut)\n\t\t\t\t- 核心：在颜色空间建立一棵二叉树，通过不断地细化这棵树来近似得到一个颜色三维直方图，然后再根据这棵树来分配采样点\n\t\t\t\t- 基于图像颜色样本分布的自适应方法，不论图像中颜色样本的分布如何，总是可以生成一个和颜色样本分布匹配良好的颜色表：在颜色样本分布密集的区域内采样点分布也相对密集，其他区域则分配了较少的采样点。且相同数目的颜色样本总是用同样数量的采样点来代表，所以颜色样本分布密集的区域，采样点的数量自然就会多，反之则相应的比较少\n\t\t\t\t- 最重要、应用最广泛的减色算法之一\n\t\t\t- k均值聚类(k-Means clustering)\n\t\t\t\t- 核心：将像素按颜色的相似程度归类\n\t\t- **从一个初始的颜色表出发，通过不断修改颜色表来改善减色效果**\n\t\t\t- 神经网络方法(ANN)\n\t\t\t\t- 颜色表通过神经元来编码，通过缓慢的调节神经元的颜色值以保证整个神经网络逐步收敛于最小误差状态（即通过神经网络产生的图像和原图之间误差最小）\n#### 直接量化实践\n- 首先我们可以来看一看getImageData后的数据\n\t- ![getImageData数据](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzljZjVjMjQzMDI0NmE0YjE0YzFlYmMzMjYwZDkwYTgwNTQzMDIucG5n?x-oss-process=image/format,png)\n\t- 可以简单看作是外层循环为rgba的打平了二维数组\n- 如果按满足需求做，只要一个主色调的话，可以把整个getImageData获得的数据，进行各个通道的平均值求值，再拼接，像这样\n\t```javascript\n\tgetUniqueColor(imageData) {\n    let res_r = 0\n    let res_g = 0\n    let res_b = 0\n    let res_a = 0\n    for (let i = 0; i < imageData.length; i += 1) {\n      if (i % 4 === 0) {\n        res_r += imageData[i]\n      } else if (i % 4 === 1) {\n        res_g += imageData[i]\n      } else if (i % 4 === 2) {\n        res_b += imageData[i]\n      } else if (i % 4 === 3) {\n        res_a += imageData[i]\n      } \n    }\n    res_r = Math.round(res_r / (imageData.length / 4))\n    res_g =  Math.round(res_g / (imageData.length / 4))\n    res_b =  Math.round(res_b / (imageData.length / 4))\n    res_a =  Math.round(res_a / (imageData.length / 4))\n    console.log('res_r', res_r)\n    console.log('res_g', res_g)\n    console.log('res_b', res_b)\n    console.log('res_a', res_a)\n  },\n\t```\n\t- 运行截图\n\t\t- ![暴力法求主色调](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzc4NzFiOTVmYzA4NWQ3NGQwNDc4OWY0ZWI5Yzc0YThmNzQ5OTYucG5n?x-oss-process=image/format,png)\n\t\t- 无相关点越多，误差越大👎\n- 我们可以“对每个颜色通道单独重新采样，将每个通道的色阶从256减少到某个指定的数字。这样得到一个新的小的多的颜色空间，而原图像中的每一个像素将被用在新的颜色空间中的最近邻取代”\n\t```javascript\n\tconst COLOR_SIZE = 40 // 单位色块的大小（像素个数，默认40）。以单位色块的平均像素值为作为统计单位\n\tconst LEVEL = 32 // 色深，颜色分区参数（0-255），总256，2^8，即8bit，4个通道（rgba），即默认色深4*8bit，32bit\n\t// 分区块，可以拓展性的求主要色板，用来做palette\n    const mapData = that.getLevelData(imageData);\n    const colors = that.getMostColor(mapData);\n    if (!colors) {\n      return\n    } else {\n      const color = that.getAverageColor(colors)\n      console.log('color', color)\n    }\n\t```\n\t- 将getImageData数据分成特定大小的区块，分别算出各个区块的averageColor，再利用map特性，将averageColor作key，count各个averageColor个数\n\t\t```javascript\n\t\t  // 获取每段的颜色数据\n\t\t  // 根据像素数据，按单位色块进行切割\n\t\t  getLevelData(imageData) {\n\t\t    const len = imageData.length;\n\t\t    const mapData = {};\n\t\t    for (let i = 0; i < len; i += COLOR_SIZE * 4) {\n\t\t      const blockColor = this.getBlockColor(imageData, i); // 该区块平均rgba [{r,g,b,a}]数据\n\t\t      // 获取各个区块的平均rgba数据，将各个通道的颜色进行LEVEL色深降级\n\t\t      // 根据r_g_b_a 建立map索引\n\t\t      const key = this.getColorLevel(blockColor);\n\t\t      !mapData[key] && (mapData[key] = []);\n\t\t      mapData[key].push(blockColor);\n\t\t    }\n\t\t    return mapData;\n\t\t  },\n\t\t\n\t\t  // 获取单位块的全部色值\n\t\t  // 并根据全部色值，计算平均色值\n\t\t  // 处理最后边界值，小于COLOR_SIZE\n\t\t  getBlockColor(imageData, start) {\n\t\t    let data = [],\n\t\t      count = COLOR_SIZE,\n\t\t      len = COLOR_SIZE * 4;\n\t\t    imageData.length <= start + len && (count = Math.floor((imageData.length - start - 1) / 4));\n\t\t    for (let i = 0; i < count; i += 4) {\n\t\t      data.push({\n\t\t        r: imageData[start + i + 0],\n\t\t        g: imageData[start + i + 1],\n\t\t        b: imageData[start + i + 2],\n\t\t        a: imageData[start + i + 3]\n\t\t      })\n\t\t    }\n\t\t    return this.getAverageColor(data);\n\t\t  },\n\t\t\n\t\t  // 取出各个通道的平均值，即为改色块的平均色值\n\t\t  getAverageColor(colorArr) {\n\t\t    const len = colorArr.length;\n\t\t    let sr = 0, sg = 0, sb = 0, sa = 0;\n\t\t    colorArr.map(function (item) {\n\t\t      sr += item.r;\n\t\t      sg += item.g;\n\t\t      sb += item.b;\n\t\t      sa += item.a;\n\t\t    });\n\t\t    return {\n\t\t      r: Math.round(sr / len),\n\t\t      g: Math.round(sg / len),\n\t\t      b: Math.round(sb / len),\n\t\t      a: Math.round(sa / len)\n\t\t    }\n\t\t  },\n\t\t\n\t\t  getColorLevel(color) {\n\t\t    return this.getLevel(color.r) + '_' + this.getLevel(color.g) + '_' + this.getLevel(color.b) + '_' + this.getLevel(color.a)\n\t\t  },\n\t\t\n\t\t  // 色深降级\n\t\t  getLevel(value) {\n\t\t    return Math.round(value / LEVEL)\n\t\t  },\n\t\t```\n\t- 把出现次数最多的averageColor区块，作为采样区块，再获取一遍averageColor，即是最终主色调\n\t\t```javascript\n\t\t  // 根据色块颜色，获取\n\t\t  getMostColor(colorData) {\n\t\t    let rst = null, len = 0;\n\t\t    for (let key in colorData) {\n\t\t      console.log('colorData[key].length', colorData[key].length)\n\t\t      console.log('colorData[key].length', colorData[key])\n\t\t      console.log('colorData[key].length', key)\n\t\t      colorData[key].length > len && (\n\t\t        rst = colorData[key],\n\t\t        len = colorData[key].length\n\t\t      )\n\t\t    }\n\t\t    return rst;\n\t\t  },\n\t\t```\n\t- 运行截图\n\t\t- ![区块获取主色调](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2ViYzI3MmNkNzU2NjNhODUxYmM2MWQ0MDE4OWJjZGI3NzQ5NDUucG5n?x-oss-process=image/format,png)\n\t\t- 颜色可信度提高了很多\n#### 拓展实践-医学灰色影像\n- 核心：将**三通道转成单通道**即可\n\t```javascript\n\tlet greyImageData = that.greyTheImage(imageData)\n    wx.canvasPutImageData({\n      canvasId: 'myCanvas',\n      x: 150,\n      y: 0,\n      width: 150,\n      height: 100,\n      data: greyImageData,\n      success (res) {\n        console.log('canvasPutImageData it worked!')\n      }\n    })\n\n  greyTheImage(imageData) {\n      // imageData有4个通道rgba\n      for (let i = 0; i < imageData.length; i += 4) {\n        let sum_rgb = 0\n        // 但我们只需要rgb三通道，a-alpha通道无用\n        for (let j = 0; j < 3; j += 1) {\n          sum_rgb = sum_rgb + imageData[i + j]\n        }\n        let grey = Math.round(sum_rgb / 3)\n        imageData[i] = grey\n        imageData[i + 1] = grey\n        imageData[i + 2] = grey\n      }\n      return imageData\n  },\n\t```\n- 运行截图\n![医学灰色影像](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzhmNWJhNzk2OTJjOWEwOTA2MDNlMzkxMzBlMDRiZTY4MTAwNzcwLnBuZw?x-oss-process=image/format,png)\n\n#### 格式化rgba输出\n- 像这样![格式化rgba输出](https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2YxNDVhYzM4YzQ1MjFkNDgzNGNkZGQ5NTNmNjQ1MWQ3NTI0NTkucG5n?x-oss-process=image/format,png)\n\t```javascript\n\t  // 对最终颜色的字符串格式化\n\t  /**\n\t   * result:{\n\t   *   hex:'#ffffff',            十六位值\n\t   *   hexa:'#ffffff00',         十六位值带alpha值\n\t   *   rgb:'rgb(0,0,0)',         RGB值\n\t   *   rgba:'rgba(0,0,0,0)'      RGB值带alpha值\n\t   * }\n\t   */\n\t\n\t  colorStrFormat(color) {\n\t    const rgba = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + (color.a / 255).toFixed(4).replace(/\\.*0+$/, '') + ')';\n\t    const rgb = 'rgb(' + color.r + ',' + color.g + ',' + color.b + ')';\n\t    const hex = '#' + this.Num2Hex(color.r) + this.Num2Hex(color.g) + this.Num2Hex(color.b);\n\t    const hexa = hex + this.Num2Hex(color.a);\n\t    return {\n\t      rgba: rgba,\n\t      rgb: rgb,\n\t      hex: hex,\n\t      hexa: hexa\n\t    }\n\t  },\n\t\n\t  Num2Hex(num) {\n\t    const hex = num.toString(16) + '';\n\t    if (hex.length < 2) {\n\t      return '0' + hex;\n\t    } else {\n\t      return hex;\n\t    }\n\t  },\n\t```\n#### 参考文献\n- [phg1024 JavaScript图像处理(6) - 减色算法(Color Reduction)](https://blog.csdn.net/u012843346/article/details/16839649)\n- [获取图片主色调的插件](https://github.com/whoiam2007s/ImgMainColor)\n- 其实也可以利用 [CSS新特性去改变背景颜色](https://blog.csdn.net/nanhupatar/article/details/82793637)，比如高斯模糊等来达到业务需求\n#### 写在后面\n- 周六听了一天 John Lennon 歌曲【这也是我拖更的原因😶 羡慕他和 Yoko 那段伊甸园般的爱情，他对 Yoko 的痴爱，他和母亲的两次分别感同身受，Beatles在一起做音乐的欢乐，他对 Sean 的宠溺父爱，但他的人生却在一次枪杀后戛然而止，心痛 心痛 🌧\n- 祝大家多多发财\n---\n","slug":"微信小程序-获取图片主色调","published":1,"updated":"2020-04-06T06:19:19.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8x6bg05000jzsp3dndc9yt3","content":"<h4 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h4><ul>\n<li>是的我要开始做：根据图片的主色调来改变一下页面背景颜色了🙆</li>\n<li>记录一下，自己碰到的问题以及思考</li>\n<li>时间多的话，会考虑将代码发在github，欢迎大家去star😘</li>\n</ul>\n<hr>\n<h4 id=\"开发准备\"><a href=\"#开发准备\" class=\"headerlink\" title=\"开发准备\"></a>开发准备</h4><ul>\n<li>理一下思路<ol>\n<li>将网络图片绘制进canvas</li>\n<li>通过canvas的getImageData获取图片的像素数据<ul>\n<li><a href=\"https://blog.csdn.net/Elle_Peng/article/details/105030971\" target=\"_blank\" rel=\"noopener\">canvas 2d 与旧版 canvas 将网络图片绘制进canvas的两种方法实践</a></li>\n</ul>\n</li>\n<li>分析目前主要用于获取图片主色调的算法，并实践</li>\n<li>得到主要色调，再将rgb转换成hsb，并对b值，进行修改，制作渐变，左侧35，右侧15<a id=\"more\"></a>\n<ul>\n<li>嗯，祝我成功<h4 id=\"颜色空间基础知识背景-减色算法\"><a href=\"#颜色空间基础知识背景-减色算法\" class=\"headerlink\" title=\"颜色空间基础知识背景+减色算法\"></a>颜色空间基础知识背景+减色算法</h4></li>\n<li><a href=\"http://www.360doc.com/content/17/0417/19/41797635_646363886.shtml\" target=\"_blank\" rel=\"noopener\">颜色空间 RGB CMY HSV HSL LAB</a></li>\n<li>图片颜色量化算法</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>比较常见的应用就是用于提取图片的主色调用于上色配色,当然也可以用于图像分割</li>\n<li>主流算法<ul>\n<li>两个大方向</li>\n<li><strong>在颜色空间合理地选取采样点来构造颜色表，使得减色后的图像和原图尽可能地接近</strong><ul>\n<li>直接量化<ul>\n<li>对每个颜色通道单独重新采样，将每个通道的色阶从256减少到某个指定的数字。这样得到一个新的小的多的颜色空间，而原图像中的每一个像素将被用在新的颜色空间中的最近邻取代</li>\n</ul>\n</li>\n<li>统计量化<ul>\n<li>核心：调整直方图使得累积分布曲线呈线性，从而使图像像素点的亮度值尽可能均匀地分布</li>\n<li>利用原图的直方图来引导采样点的选取，使得每个采样点可以大致覆盖相同数量的像素点</li>\n<li>对每个颜色通道建立直方图，然后根据这些直方图对各个颜色通道单独采样，在像素值分布多的区域进行密集采样，别的区域稀疏采样，再利用这些采样点来组合成最终的颜色表，原图中的每个像素点用颜色表中最接近的颜色替换掉</li>\n</ul>\n</li>\n<li>颜色空间分割(Median-Cut)<ul>\n<li>核心：在颜色空间建立一棵二叉树，通过不断地细化这棵树来近似得到一个颜色三维直方图，然后再根据这棵树来分配采样点</li>\n<li>基于图像颜色样本分布的自适应方法，不论图像中颜色样本的分布如何，总是可以生成一个和颜色样本分布匹配良好的颜色表：在颜色样本分布密集的区域内采样点分布也相对密集，其他区域则分配了较少的采样点。且相同数目的颜色样本总是用同样数量的采样点来代表，所以颜色样本分布密集的区域，采样点的数量自然就会多，反之则相应的比较少</li>\n<li>最重要、应用最广泛的减色算法之一</li>\n</ul>\n</li>\n<li>k均值聚类(k-Means clustering)<ul>\n<li>核心：将像素按颜色的相似程度归类</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>从一个初始的颜色表出发，通过不断修改颜色表来改善减色效果</strong><ul>\n<li>神经网络方法(ANN)<ul>\n<li>颜色表通过神经元来编码，通过缓慢的调节神经元的颜色值以保证整个神经网络逐步收敛于最小误差状态（即通过神经网络产生的图像和原图之间误差最小）<h4 id=\"直接量化实践\"><a href=\"#直接量化实践\" class=\"headerlink\" title=\"直接量化实践\"></a>直接量化实践</h4><ul>\n<li>首先我们可以来看一看getImageData后的数据</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzljZjVjMjQzMDI0NmE0YjE0YzFlYmMzMjYwZDkwYTgwNTQzMDIucG5n?x-oss-process=image/format,png\" alt=\"getImageData数据\"></li>\n<li>可以简单看作是外层循环为rgba的打平了二维数组<ul>\n<li>如果按满足需求做，只要一个主色调的话，可以把整个getImageData获得的数据，进行各个通道的平均值求值，再拼接，像这样<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUniqueColor(imageData) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> res_r = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"keyword\">let</span> res_g = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"keyword\">let</span> res_b = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"keyword\">let</span> res_a = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; imageData.length; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (i % <span class=\"number\">4</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">       res_r += imageData[i]</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i % <span class=\"number\">4</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">       res_g += imageData[i]</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i % <span class=\"number\">4</span> === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">       res_b += imageData[i]</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i % <span class=\"number\">4</span> === <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">       res_a += imageData[i]</span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   res_r = <span class=\"built_in\">Math</span>.round(res_r / (imageData.length / <span class=\"number\">4</span>))</span><br><span class=\"line\">   res_g =  <span class=\"built_in\">Math</span>.round(res_g / (imageData.length / <span class=\"number\">4</span>))</span><br><span class=\"line\">   res_b =  <span class=\"built_in\">Math</span>.round(res_b / (imageData.length / <span class=\"number\">4</span>))</span><br><span class=\"line\">   res_a =  <span class=\"built_in\">Math</span>.round(res_a / (imageData.length / <span class=\"number\">4</span>))</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'res_r'</span>, res_r)</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'res_g'</span>, res_g)</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'res_b'</span>, res_b)</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'res_a'</span>, res_a)</span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>运行截图<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzc4NzFiOTVmYzA4NWQ3NGQwNDc4OWY0ZWI5Yzc0YThmNzQ5OTYucG5n?x-oss-process=image/format,png\" alt=\"暴力法求主色调\"></li>\n<li>无相关点越多，误差越大👎<ul>\n<li>我们可以“对每个颜色通道单独重新采样，将每个通道的色阶从256减少到某个指定的数字。这样得到一个新的小的多的颜色空间，而原图像中的每一个像素将被用在新的颜色空间中的最近邻取代”<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> COLOR_SIZE = <span class=\"number\">40</span> <span class=\"comment\">// 单位色块的大小（像素个数，默认40）。以单位色块的平均像素值为作为统计单位</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> LEVEL = <span class=\"number\">32</span> <span class=\"comment\">// 色深，颜色分区参数（0-255），总256，2^8，即8bit，4个通道（rgba），即默认色深4*8bit，32bit</span></span><br><span class=\"line\"><span class=\"comment\">// 分区块，可以拓展性的求主要色板，用来做palette</span></span><br><span class=\"line\">   <span class=\"keyword\">const</span> mapData = that.getLevelData(imageData);</span><br><span class=\"line\">   <span class=\"keyword\">const</span> colors = that.getMostColor(mapData);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!colors) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span></span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">const</span> color = that.getAverageColor(colors)</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">'color'</span>, color)</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>将getImageData数据分成特定大小的区块，分别算出各个区块的averageColor，再利用map特性，将averageColor作key，count各个averageColor个数  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取每段的颜色数据</span></span><br><span class=\"line\"><span class=\"comment\">// 根据像素数据，按单位色块进行切割</span></span><br><span class=\"line\">getLevelData(imageData) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = imageData.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> mapData = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i += COLOR_SIZE * <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> blockColor = <span class=\"keyword\">this</span>.getBlockColor(imageData, i); <span class=\"comment\">// 该区块平均rgba [&#123;r,g,b,a&#125;]数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取各个区块的平均rgba数据，将各个通道的颜色进行LEVEL色深降级</span></span><br><span class=\"line\">    <span class=\"comment\">// 根据r_g_b_a 建立map索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = <span class=\"keyword\">this</span>.getColorLevel(blockColor);</span><br><span class=\"line\">    !mapData[key] &amp;&amp; (mapData[key] = []);</span><br><span class=\"line\">    mapData[key].push(blockColor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> mapData;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\">// 获取单位块的全部色值</span></span><br><span class=\"line\"><span class=\"comment\">// 并根据全部色值，计算平均色值</span></span><br><span class=\"line\"><span class=\"comment\">// 处理最后边界值，小于COLOR_SIZE</span></span><br><span class=\"line\">getBlockColor(imageData, start) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data = [],</span><br><span class=\"line\">    count = COLOR_SIZE,</span><br><span class=\"line\">    len = COLOR_SIZE * <span class=\"number\">4</span>;</span><br><span class=\"line\">  imageData.length &lt;= start + len &amp;&amp; (count = <span class=\"built_in\">Math</span>.floor((imageData.length - start - <span class=\"number\">1</span>) / <span class=\"number\">4</span>));</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; count; i += <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    data.push(&#123;</span><br><span class=\"line\">      r: imageData[start + i + <span class=\"number\">0</span>],</span><br><span class=\"line\">      g: imageData[start + i + <span class=\"number\">1</span>],</span><br><span class=\"line\">      b: imageData[start + i + <span class=\"number\">2</span>],</span><br><span class=\"line\">      a: imageData[start + i + <span class=\"number\">3</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getAverageColor(data);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\">// 取出各个通道的平均值，即为改色块的平均色值</span></span><br><span class=\"line\">getAverageColor(colorArr) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = colorArr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sr = <span class=\"number\">0</span>, sg = <span class=\"number\">0</span>, sb = <span class=\"number\">0</span>, sa = <span class=\"number\">0</span>;</span><br><span class=\"line\">  colorArr.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    sr += item.r;</span><br><span class=\"line\">    sg += item.g;</span><br><span class=\"line\">    sb += item.b;</span><br><span class=\"line\">    sa += item.a;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    r: <span class=\"built_in\">Math</span>.round(sr / len),</span><br><span class=\"line\">    g: <span class=\"built_in\">Math</span>.round(sg / len),</span><br><span class=\"line\">    b: <span class=\"built_in\">Math</span>.round(sb / len),</span><br><span class=\"line\">    a: <span class=\"built_in\">Math</span>.round(sa / len)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">getColorLevel(color) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getLevel(color.r) + <span class=\"string\">'_'</span> + <span class=\"keyword\">this</span>.getLevel(color.g) + <span class=\"string\">'_'</span> + <span class=\"keyword\">this</span>.getLevel(color.b) + <span class=\"string\">'_'</span> + <span class=\"keyword\">this</span>.getLevel(color.a)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\">// 色深降级</span></span><br><span class=\"line\">getLevel(value) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.round(value / LEVEL)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li>把出现次数最多的averageColor区块，作为采样区块，再获取一遍averageColor，即是最终主色调  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据色块颜色，获取</span></span><br><span class=\"line\">getMostColor(colorData) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rst = <span class=\"literal\">null</span>, len = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> colorData) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'colorData[key].length'</span>, colorData[key].length)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'colorData[key].length'</span>, colorData[key])</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'colorData[key].length'</span>, key)</span><br><span class=\"line\">    colorData[key].length &gt; len &amp;&amp; (</span><br><span class=\"line\">      rst = colorData[key],</span><br><span class=\"line\">      len = colorData[key].length</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rst;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li>运行截图<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2ViYzI3MmNkNzU2NjNhODUxYmM2MWQ0MDE4OWJjZGI3NzQ5NDUucG5n?x-oss-process=image/format,png\" alt=\"区块获取主色调\"></li>\n<li>颜色可信度提高了很多<h4 id=\"拓展实践-医学灰色影像\"><a href=\"#拓展实践-医学灰色影像\" class=\"headerlink\" title=\"拓展实践-医学灰色影像\"></a>拓展实践-医学灰色影像</h4><ul>\n<li>核心：将<strong>三通道转成单通道</strong>即可<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> greyImageData = that.greyTheImage(imageData)</span><br><span class=\"line\">   wx.canvasPutImageData(&#123;</span><br><span class=\"line\">     canvasId: <span class=\"string\">'myCanvas'</span>,</span><br><span class=\"line\">     x: <span class=\"number\">150</span>,</span><br><span class=\"line\">     y: <span class=\"number\">0</span>,</span><br><span class=\"line\">     width: <span class=\"number\">150</span>,</span><br><span class=\"line\">     height: <span class=\"number\">100</span>,</span><br><span class=\"line\">     data: greyImageData,</span><br><span class=\"line\">     success (res) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">'canvasPutImageData it worked!'</span>)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"> greyTheImage(imageData) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// imageData有4个通道rgba</span></span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; imageData.length; i += <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">let</span> sum_rgb = <span class=\"number\">0</span></span><br><span class=\"line\">       <span class=\"comment\">// 但我们只需要rgb三通道，a-alpha通道无用</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">         sum_rgb = sum_rgb + imageData[i + j]</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">let</span> grey = <span class=\"built_in\">Math</span>.round(sum_rgb / <span class=\"number\">3</span>)</span><br><span class=\"line\">       imageData[i] = grey</span><br><span class=\"line\">       imageData[i + <span class=\"number\">1</span>] = grey</span><br><span class=\"line\">       imageData[i + <span class=\"number\">2</span>] = grey</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> imageData</span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure></li>\n<li>运行截图<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzhmNWJhNzk2OTJjOWEwOTA2MDNlMzkxMzBlMDRiZTY4MTAwNzcwLnBuZw?x-oss-process=image/format,png\" alt=\"医学灰色影像\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"格式化rgba输出\"><a href=\"#格式化rgba输出\" class=\"headerlink\" title=\"格式化rgba输出\"></a>格式化rgba输出</h4><ul>\n<li>像这样<img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2YxNDVhYzM4YzQ1MjFkNDgzNGNkZGQ5NTNmNjQ1MWQ3NTI0NTkucG5n?x-oss-process=image/format,png\" alt=\"格式化rgba输出\">  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对最终颜色的字符串格式化</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * result:&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *   hex:'#ffffff',            十六位值</span></span><br><span class=\"line\"><span class=\"comment\"> *   hexa:'#ffffff00',         十六位值带alpha值</span></span><br><span class=\"line\"><span class=\"comment\"> *   rgb:'rgb(0,0,0)',         RGB值</span></span><br><span class=\"line\"><span class=\"comment\"> *   rgba:'rgba(0,0,0,0)'      RGB值带alpha值</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">colorStrFormat(color) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rgba = <span class=\"string\">'rgba('</span> + color.r + <span class=\"string\">','</span> + color.g + <span class=\"string\">','</span> + color.b + <span class=\"string\">','</span> + (color.a / <span class=\"number\">255</span>).toFixed(<span class=\"number\">4</span>).replace(<span class=\"regexp\">/\\.*0+$/</span>, <span class=\"string\">''</span>) + <span class=\"string\">')'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rgb = <span class=\"string\">'rgb('</span> + color.r + <span class=\"string\">','</span> + color.g + <span class=\"string\">','</span> + color.b + <span class=\"string\">')'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hex = <span class=\"string\">'#'</span> + <span class=\"keyword\">this</span>.Num2Hex(color.r) + <span class=\"keyword\">this</span>.Num2Hex(color.g) + <span class=\"keyword\">this</span>.Num2Hex(color.b);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hexa = hex + <span class=\"keyword\">this</span>.Num2Hex(color.a);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    rgba: rgba,</span><br><span class=\"line\">    rgb: rgb,</span><br><span class=\"line\">    hex: hex,</span><br><span class=\"line\">    hexa: hexa</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">Num2Hex(num) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hex = num.toString(<span class=\"number\">16</span>) + <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hex.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'0'</span> + hex;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hex;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h4 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h4></li>\n<li><a href=\"https://blog.csdn.net/u012843346/article/details/16839649\" target=\"_blank\" rel=\"noopener\">phg1024 JavaScript图像处理(6) - 减色算法(Color Reduction)</a></li>\n<li><a href=\"https://github.com/whoiam2007s/ImgMainColor\" target=\"_blank\" rel=\"noopener\">获取图片主色调的插件</a></li>\n<li>其实也可以利用 <a href=\"https://blog.csdn.net/nanhupatar/article/details/82793637\" target=\"_blank\" rel=\"noopener\">CSS新特性去改变背景颜色</a>，比如高斯模糊等来达到业务需求<h4 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h4></li>\n<li>周六听了一天 John Lennon 歌曲【这也是我拖更的原因😶 羡慕他和 Yoko 那段伊甸园般的爱情，他对 Yoko 的痴爱，他和母亲的两次分别感同身受，Beatles在一起做音乐的欢乐，他对 Sean 的宠溺父爱，但他的人生却在一次枪杀后戛然而止，心痛 心痛 🌧</li>\n<li>祝大家多多发财</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"<h4 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h4><ul>\n<li>是的我要开始做：根据图片的主色调来改变一下页面背景颜色了🙆</li>\n<li>记录一下，自己碰到的问题以及思考</li>\n<li>时间多的话，会考虑将代码发在github，欢迎大家去star😘</li>\n</ul>\n<hr>\n<h4 id=\"开发准备\"><a href=\"#开发准备\" class=\"headerlink\" title=\"开发准备\"></a>开发准备</h4><ul>\n<li>理一下思路<ol>\n<li>将网络图片绘制进canvas</li>\n<li>通过canvas的getImageData获取图片的像素数据<ul>\n<li><a href=\"https://blog.csdn.net/Elle_Peng/article/details/105030971\" target=\"_blank\" rel=\"noopener\">canvas 2d 与旧版 canvas 将网络图片绘制进canvas的两种方法实践</a></li>\n</ul>\n</li>\n<li>分析目前主要用于获取图片主色调的算法，并实践</li>\n<li>得到主要色调，再将rgb转换成hsb，并对b值，进行修改，制作渐变，左侧35，右侧15","more":"<ul>\n<li>嗯，祝我成功<h4 id=\"颜色空间基础知识背景-减色算法\"><a href=\"#颜色空间基础知识背景-减色算法\" class=\"headerlink\" title=\"颜色空间基础知识背景+减色算法\"></a>颜色空间基础知识背景+减色算法</h4></li>\n<li><a href=\"http://www.360doc.com/content/17/0417/19/41797635_646363886.shtml\" target=\"_blank\" rel=\"noopener\">颜色空间 RGB CMY HSV HSL LAB</a></li>\n<li>图片颜色量化算法</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>比较常见的应用就是用于提取图片的主色调用于上色配色,当然也可以用于图像分割</li>\n<li>主流算法<ul>\n<li>两个大方向</li>\n<li><strong>在颜色空间合理地选取采样点来构造颜色表，使得减色后的图像和原图尽可能地接近</strong><ul>\n<li>直接量化<ul>\n<li>对每个颜色通道单独重新采样，将每个通道的色阶从256减少到某个指定的数字。这样得到一个新的小的多的颜色空间，而原图像中的每一个像素将被用在新的颜色空间中的最近邻取代</li>\n</ul>\n</li>\n<li>统计量化<ul>\n<li>核心：调整直方图使得累积分布曲线呈线性，从而使图像像素点的亮度值尽可能均匀地分布</li>\n<li>利用原图的直方图来引导采样点的选取，使得每个采样点可以大致覆盖相同数量的像素点</li>\n<li>对每个颜色通道建立直方图，然后根据这些直方图对各个颜色通道单独采样，在像素值分布多的区域进行密集采样，别的区域稀疏采样，再利用这些采样点来组合成最终的颜色表，原图中的每个像素点用颜色表中最接近的颜色替换掉</li>\n</ul>\n</li>\n<li>颜色空间分割(Median-Cut)<ul>\n<li>核心：在颜色空间建立一棵二叉树，通过不断地细化这棵树来近似得到一个颜色三维直方图，然后再根据这棵树来分配采样点</li>\n<li>基于图像颜色样本分布的自适应方法，不论图像中颜色样本的分布如何，总是可以生成一个和颜色样本分布匹配良好的颜色表：在颜色样本分布密集的区域内采样点分布也相对密集，其他区域则分配了较少的采样点。且相同数目的颜色样本总是用同样数量的采样点来代表，所以颜色样本分布密集的区域，采样点的数量自然就会多，反之则相应的比较少</li>\n<li>最重要、应用最广泛的减色算法之一</li>\n</ul>\n</li>\n<li>k均值聚类(k-Means clustering)<ul>\n<li>核心：将像素按颜色的相似程度归类</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>从一个初始的颜色表出发，通过不断修改颜色表来改善减色效果</strong><ul>\n<li>神经网络方法(ANN)<ul>\n<li>颜色表通过神经元来编码，通过缓慢的调节神经元的颜色值以保证整个神经网络逐步收敛于最小误差状态（即通过神经网络产生的图像和原图之间误差最小）<h4 id=\"直接量化实践\"><a href=\"#直接量化实践\" class=\"headerlink\" title=\"直接量化实践\"></a>直接量化实践</h4><ul>\n<li>首先我们可以来看一看getImageData后的数据</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzljZjVjMjQzMDI0NmE0YjE0YzFlYmMzMjYwZDkwYTgwNTQzMDIucG5n?x-oss-process=image/format,png\" alt=\"getImageData数据\"></li>\n<li>可以简单看作是外层循环为rgba的打平了二维数组<ul>\n<li>如果按满足需求做，只要一个主色调的话，可以把整个getImageData获得的数据，进行各个通道的平均值求值，再拼接，像这样<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUniqueColor(imageData) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> res_r = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"keyword\">let</span> res_g = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"keyword\">let</span> res_b = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"keyword\">let</span> res_a = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; imageData.length; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (i % <span class=\"number\">4</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">       res_r += imageData[i]</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i % <span class=\"number\">4</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">       res_g += imageData[i]</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i % <span class=\"number\">4</span> === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">       res_b += imageData[i]</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i % <span class=\"number\">4</span> === <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">       res_a += imageData[i]</span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   res_r = <span class=\"built_in\">Math</span>.round(res_r / (imageData.length / <span class=\"number\">4</span>))</span><br><span class=\"line\">   res_g =  <span class=\"built_in\">Math</span>.round(res_g / (imageData.length / <span class=\"number\">4</span>))</span><br><span class=\"line\">   res_b =  <span class=\"built_in\">Math</span>.round(res_b / (imageData.length / <span class=\"number\">4</span>))</span><br><span class=\"line\">   res_a =  <span class=\"built_in\">Math</span>.round(res_a / (imageData.length / <span class=\"number\">4</span>))</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'res_r'</span>, res_r)</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'res_g'</span>, res_g)</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'res_b'</span>, res_b)</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'res_a'</span>, res_a)</span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>运行截图<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzc4NzFiOTVmYzA4NWQ3NGQwNDc4OWY0ZWI5Yzc0YThmNzQ5OTYucG5n?x-oss-process=image/format,png\" alt=\"暴力法求主色调\"></li>\n<li>无相关点越多，误差越大👎<ul>\n<li>我们可以“对每个颜色通道单独重新采样，将每个通道的色阶从256减少到某个指定的数字。这样得到一个新的小的多的颜色空间，而原图像中的每一个像素将被用在新的颜色空间中的最近邻取代”<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> COLOR_SIZE = <span class=\"number\">40</span> <span class=\"comment\">// 单位色块的大小（像素个数，默认40）。以单位色块的平均像素值为作为统计单位</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> LEVEL = <span class=\"number\">32</span> <span class=\"comment\">// 色深，颜色分区参数（0-255），总256，2^8，即8bit，4个通道（rgba），即默认色深4*8bit，32bit</span></span><br><span class=\"line\"><span class=\"comment\">// 分区块，可以拓展性的求主要色板，用来做palette</span></span><br><span class=\"line\">   <span class=\"keyword\">const</span> mapData = that.getLevelData(imageData);</span><br><span class=\"line\">   <span class=\"keyword\">const</span> colors = that.getMostColor(mapData);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!colors) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span></span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">const</span> color = that.getAverageColor(colors)</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">'color'</span>, color)</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>将getImageData数据分成特定大小的区块，分别算出各个区块的averageColor，再利用map特性，将averageColor作key，count各个averageColor个数  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取每段的颜色数据</span></span><br><span class=\"line\"><span class=\"comment\">// 根据像素数据，按单位色块进行切割</span></span><br><span class=\"line\">getLevelData(imageData) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = imageData.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> mapData = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i += COLOR_SIZE * <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> blockColor = <span class=\"keyword\">this</span>.getBlockColor(imageData, i); <span class=\"comment\">// 该区块平均rgba [&#123;r,g,b,a&#125;]数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取各个区块的平均rgba数据，将各个通道的颜色进行LEVEL色深降级</span></span><br><span class=\"line\">    <span class=\"comment\">// 根据r_g_b_a 建立map索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = <span class=\"keyword\">this</span>.getColorLevel(blockColor);</span><br><span class=\"line\">    !mapData[key] &amp;&amp; (mapData[key] = []);</span><br><span class=\"line\">    mapData[key].push(blockColor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> mapData;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\">// 获取单位块的全部色值</span></span><br><span class=\"line\"><span class=\"comment\">// 并根据全部色值，计算平均色值</span></span><br><span class=\"line\"><span class=\"comment\">// 处理最后边界值，小于COLOR_SIZE</span></span><br><span class=\"line\">getBlockColor(imageData, start) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data = [],</span><br><span class=\"line\">    count = COLOR_SIZE,</span><br><span class=\"line\">    len = COLOR_SIZE * <span class=\"number\">4</span>;</span><br><span class=\"line\">  imageData.length &lt;= start + len &amp;&amp; (count = <span class=\"built_in\">Math</span>.floor((imageData.length - start - <span class=\"number\">1</span>) / <span class=\"number\">4</span>));</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; count; i += <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    data.push(&#123;</span><br><span class=\"line\">      r: imageData[start + i + <span class=\"number\">0</span>],</span><br><span class=\"line\">      g: imageData[start + i + <span class=\"number\">1</span>],</span><br><span class=\"line\">      b: imageData[start + i + <span class=\"number\">2</span>],</span><br><span class=\"line\">      a: imageData[start + i + <span class=\"number\">3</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getAverageColor(data);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\">// 取出各个通道的平均值，即为改色块的平均色值</span></span><br><span class=\"line\">getAverageColor(colorArr) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = colorArr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sr = <span class=\"number\">0</span>, sg = <span class=\"number\">0</span>, sb = <span class=\"number\">0</span>, sa = <span class=\"number\">0</span>;</span><br><span class=\"line\">  colorArr.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    sr += item.r;</span><br><span class=\"line\">    sg += item.g;</span><br><span class=\"line\">    sb += item.b;</span><br><span class=\"line\">    sa += item.a;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    r: <span class=\"built_in\">Math</span>.round(sr / len),</span><br><span class=\"line\">    g: <span class=\"built_in\">Math</span>.round(sg / len),</span><br><span class=\"line\">    b: <span class=\"built_in\">Math</span>.round(sb / len),</span><br><span class=\"line\">    a: <span class=\"built_in\">Math</span>.round(sa / len)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">getColorLevel(color) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getLevel(color.r) + <span class=\"string\">'_'</span> + <span class=\"keyword\">this</span>.getLevel(color.g) + <span class=\"string\">'_'</span> + <span class=\"keyword\">this</span>.getLevel(color.b) + <span class=\"string\">'_'</span> + <span class=\"keyword\">this</span>.getLevel(color.a)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\">// 色深降级</span></span><br><span class=\"line\">getLevel(value) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.round(value / LEVEL)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li>把出现次数最多的averageColor区块，作为采样区块，再获取一遍averageColor，即是最终主色调  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据色块颜色，获取</span></span><br><span class=\"line\">getMostColor(colorData) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rst = <span class=\"literal\">null</span>, len = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> colorData) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'colorData[key].length'</span>, colorData[key].length)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'colorData[key].length'</span>, colorData[key])</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'colorData[key].length'</span>, key)</span><br><span class=\"line\">    colorData[key].length &gt; len &amp;&amp; (</span><br><span class=\"line\">      rst = colorData[key],</span><br><span class=\"line\">      len = colorData[key].length</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rst;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li>运行截图<ul>\n<li><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2ViYzI3MmNkNzU2NjNhODUxYmM2MWQ0MDE4OWJjZGI3NzQ5NDUucG5n?x-oss-process=image/format,png\" alt=\"区块获取主色调\"></li>\n<li>颜色可信度提高了很多<h4 id=\"拓展实践-医学灰色影像\"><a href=\"#拓展实践-医学灰色影像\" class=\"headerlink\" title=\"拓展实践-医学灰色影像\"></a>拓展实践-医学灰色影像</h4><ul>\n<li>核心：将<strong>三通道转成单通道</strong>即可<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> greyImageData = that.greyTheImage(imageData)</span><br><span class=\"line\">   wx.canvasPutImageData(&#123;</span><br><span class=\"line\">     canvasId: <span class=\"string\">'myCanvas'</span>,</span><br><span class=\"line\">     x: <span class=\"number\">150</span>,</span><br><span class=\"line\">     y: <span class=\"number\">0</span>,</span><br><span class=\"line\">     width: <span class=\"number\">150</span>,</span><br><span class=\"line\">     height: <span class=\"number\">100</span>,</span><br><span class=\"line\">     data: greyImageData,</span><br><span class=\"line\">     success (res) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">'canvasPutImageData it worked!'</span>)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"> greyTheImage(imageData) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// imageData有4个通道rgba</span></span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; imageData.length; i += <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">let</span> sum_rgb = <span class=\"number\">0</span></span><br><span class=\"line\">       <span class=\"comment\">// 但我们只需要rgb三通道，a-alpha通道无用</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">         sum_rgb = sum_rgb + imageData[i + j]</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">let</span> grey = <span class=\"built_in\">Math</span>.round(sum_rgb / <span class=\"number\">3</span>)</span><br><span class=\"line\">       imageData[i] = grey</span><br><span class=\"line\">       imageData[i + <span class=\"number\">1</span>] = grey</span><br><span class=\"line\">       imageData[i + <span class=\"number\">2</span>] = grey</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> imageData</span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure></li>\n<li>运行截图<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlLzhmNWJhNzk2OTJjOWEwOTA2MDNlMzkxMzBlMDRiZTY4MTAwNzcwLnBuZw?x-oss-process=image/format,png\" alt=\"医学灰色影像\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"格式化rgba输出\"><a href=\"#格式化rgba输出\" class=\"headerlink\" title=\"格式化rgba输出\"></a>格式化rgba输出</h4><ul>\n<li>像这样<img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3AwLm1laXR1YW4ubmV0L215dmlkZW9kaXN0cmlidXRlL2YxNDVhYzM4YzQ1MjFkNDgzNGNkZGQ5NTNmNjQ1MWQ3NTI0NTkucG5n?x-oss-process=image/format,png\" alt=\"格式化rgba输出\">  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对最终颜色的字符串格式化</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * result:&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *   hex:'#ffffff',            十六位值</span></span><br><span class=\"line\"><span class=\"comment\"> *   hexa:'#ffffff00',         十六位值带alpha值</span></span><br><span class=\"line\"><span class=\"comment\"> *   rgb:'rgb(0,0,0)',         RGB值</span></span><br><span class=\"line\"><span class=\"comment\"> *   rgba:'rgba(0,0,0,0)'      RGB值带alpha值</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">colorStrFormat(color) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rgba = <span class=\"string\">'rgba('</span> + color.r + <span class=\"string\">','</span> + color.g + <span class=\"string\">','</span> + color.b + <span class=\"string\">','</span> + (color.a / <span class=\"number\">255</span>).toFixed(<span class=\"number\">4</span>).replace(<span class=\"regexp\">/\\.*0+$/</span>, <span class=\"string\">''</span>) + <span class=\"string\">')'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rgb = <span class=\"string\">'rgb('</span> + color.r + <span class=\"string\">','</span> + color.g + <span class=\"string\">','</span> + color.b + <span class=\"string\">')'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hex = <span class=\"string\">'#'</span> + <span class=\"keyword\">this</span>.Num2Hex(color.r) + <span class=\"keyword\">this</span>.Num2Hex(color.g) + <span class=\"keyword\">this</span>.Num2Hex(color.b);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hexa = hex + <span class=\"keyword\">this</span>.Num2Hex(color.a);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    rgba: rgba,</span><br><span class=\"line\">    rgb: rgb,</span><br><span class=\"line\">    hex: hex,</span><br><span class=\"line\">    hexa: hexa</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">Num2Hex(num) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hex = num.toString(<span class=\"number\">16</span>) + <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hex.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'0'</span> + hex;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hex;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h4 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h4></li>\n<li><a href=\"https://blog.csdn.net/u012843346/article/details/16839649\" target=\"_blank\" rel=\"noopener\">phg1024 JavaScript图像处理(6) - 减色算法(Color Reduction)</a></li>\n<li><a href=\"https://github.com/whoiam2007s/ImgMainColor\" target=\"_blank\" rel=\"noopener\">获取图片主色调的插件</a></li>\n<li>其实也可以利用 <a href=\"https://blog.csdn.net/nanhupatar/article/details/82793637\" target=\"_blank\" rel=\"noopener\">CSS新特性去改变背景颜色</a>，比如高斯模糊等来达到业务需求<h4 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h4></li>\n<li>周六听了一天 John Lennon 歌曲【这也是我拖更的原因😶 羡慕他和 Yoko 那段伊甸园般的爱情，他对 Yoko 的痴爱，他和母亲的两次分别感同身受，Beatles在一起做音乐的欢乐，他对 Sean 的宠溺父爱，但他的人生却在一次枪杀后戛然而止，心痛 心痛 🌧</li>\n<li>祝大家多多发财</li>\n</ul>\n<hr>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck8x6bfzr0001zsp3a2v0a724","category_id":"ck8x6bfzu0003zsp34f7ib86x","_id":"ck8x6bfzz0009zsp3bfye293j"},{"post_id":"ck8x6bfzt0002zsp34o0i4erx","category_id":"ck8x6bfzy0006zsp360ic6hjh","_id":"ck8x6bg00000dzsp3aq5rekvl"},{"post_id":"ck8x6bfzx0005zsp3cvuzg17y","category_id":"ck8x6bfzz000azsp33sz4c38x","_id":"ck8x6bg01000fzsp3ad6527au"},{"post_id":"ck8x6bg03000gzsp37luzbm5r","category_id":"ck8x6bfzy0006zsp360ic6hjh","_id":"ck8x6bg06000lzsp3hsd328cs"},{"post_id":"ck8x6bg04000hzsp37brrhyl3","category_id":"ck8x6bfzz000azsp33sz4c38x","_id":"ck8x6bg06000nzsp348y4d79g"},{"post_id":"ck8x6bg05000jzsp3dndc9yt3","category_id":"ck8x6bfzz000azsp33sz4c38x","_id":"ck8x6bg07000ozsp368wj8w8n"}],"PostTag":[{"post_id":"ck8x6bfzr0001zsp3a2v0a724","tag_id":"ck8x6bfzw0004zsp3709c6iyt","_id":"ck8x6bfzz0008zsp3aq3ifznp"},{"post_id":"ck8x6bfzt0002zsp34o0i4erx","tag_id":"ck8x6bfzy0007zsp376p0ffxc","_id":"ck8x6bg00000czsp30nsta92r"},{"post_id":"ck8x6bfzx0005zsp3cvuzg17y","tag_id":"ck8x6bg00000bzsp33e1hbdq4","_id":"ck8x6bg00000ezsp39w87fl84"},{"post_id":"ck8x6bg03000gzsp37luzbm5r","tag_id":"ck8x6bfzy0007zsp376p0ffxc","_id":"ck8x6bg05000izsp37h1a739u"},{"post_id":"ck8x6bg04000hzsp37brrhyl3","tag_id":"ck8x6bg00000bzsp33e1hbdq4","_id":"ck8x6bg06000kzsp3bfy5a8k6"},{"post_id":"ck8x6bg05000jzsp3dndc9yt3","tag_id":"ck8x6bg00000bzsp33e1hbdq4","_id":"ck8x6bg06000mzsp33fl10hs8"}],"Tag":[{"name":"算法","_id":"ck8x6bfzw0004zsp3709c6iyt"},{"name":"前端概念","_id":"ck8x6bfzy0007zsp376p0ffxc"},{"name":"微信小程序","_id":"ck8x6bg00000bzsp33e1hbdq4"}]}}