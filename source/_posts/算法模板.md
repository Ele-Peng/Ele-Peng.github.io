---
title: 算法模板
date: 2020-09-24 23:46:30
tags:
---



<style  type="text/css">
.lx-entry a {
    color: #191919;
    padding: 2px 0 1px 0;
    text-decoration: none;
    background-image: linear-gradient( transparent 0%, transparent calc(50% - 9px), rgba(247,65,65,.761) calc(50% - 9px), rgba(247,65,65,.761) 100% );
    transition: background-position 120ms ease-in-out, padding 120ms ease-in-out;
    background-size: 100% 200%;
    background-position: 0 0;
    word-break: break-word;
}

.lx-entry a:hover {
  background-image: linear-gradient( transparent 0%, transparent calc(50% - 9px), rgba(247,65,65,.761) calc(50% - 9px), rgba(247,65,65,.761) 100% );
  background-position: 0 100%;
}

.post-button a:hover {
  background-image: linear-gradient( transparent 0%, transparent calc(50% - 9px), transparent calc(50% - 9px), transparent 100% ) !important;
  background-position: 0 100% !important;
  outline: none !important;
  text-decoration: none !important;
}
</style>

## 写在前面
- 常见算法模板（自己总结，非官方）

<!-- more -->

## 数据结构
### 数组
- [26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)
- [66. 加一](https://leetcode-cn.com/problems/plus-one/)
- [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)
- [122. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
- [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)
- [✨189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)
- [✨264. 丑数-ii](https://leetcode-cn.com/problems/ugly-number-ii/)
- [874. 模拟行走机器人](https://leetcode-cn.com/problems/walking-robot-simulation/)

### 链表
- [✨141. 环形链表-i](https://leetcode-cn.com/problems/linked-list-cycle/)
- [✨142. 环形链表-ii](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
- [✨206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)


### 栈
- [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)
- [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

### 队列
- [622. 设计循环队列](https://leetcode-cn.com/problems/design-circular-queue/)
- [🤔641. 设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque/)

### Hash 
- [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)
- [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)
- [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)
- [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)
- [860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)

### [滑动窗口](https://leetcode-cn.com/problems/sliding-window-maximum/solution/239-hua-dong-chuang-kou-zui-da-zhi-by-alexer-660/)
- [✨239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)
- 

### 树
- [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
- [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)
- [💉25. k个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)
- [💉92. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
- [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)
- [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)
- [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)
- [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)
- [✨297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)
- [✨226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)
- [✨116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)
- [✨98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)
- [✨112. 路经总和](https://leetcode-cn.com/problems/path-sum/)
- [✨104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
- [✨111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)
- [✨450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)
- [✨105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
- [✨106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
- [✨236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
- [🤔️114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)
- [✨144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)
- [✨94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)
- [✨145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)
- [✨102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
- [✨589. N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)
- [✨590. N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)
- [✨429. N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

## 前缀和
- [✨560. 和为k的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

## 单调栈
- [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
- [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
- [✨496. 下一个更大元素-i](https://leetcode-cn.com/problems/next-greater-element-i/)
- [✨503. 下一个更大元素-ii](https://leetcode-cn.com/problems/next-greater-element-ii/)
- [✨739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)


```javascript
// 84. 柱状图中最大的矩形
// 单调栈
var largestRectangleArea = function(heights) {
  let area = 0;
  let stack = [];
  let current = 0;
  heights = [0, ...heights, 0];
  while (current < heights.length) {
    // 栈不为空 且 当前元素 要 大于 栈顶元素
    // 才能被框住
    while(stack.length && heights[current] < heights[stack[stack.length - 1]]) {
      let h = heights[stack[stack.length - 1]];
      stack.pop();
      if (!stack.length) break;
      area = Math.max(area, (current - stack[stack.length - 1] - 1) * h)
    }
    stack.push(current);
    current ++;
  }
  return area;
};



let stack = [];
let current = 0;
while(current < nums.length) {
    // 这是单调递增栈，视情况而定，当前元素是否大于栈顶元素
    while(stack.length && nums[current] < nums[stack[stack.length -1]]) {
        let base = nums[stack[stack.length -1]];
        stack.pop();
        if (!stack.length) break;
        // some code ...
    }
    stack.push(current);
    current ++;
}
```


## 双指针
- [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)
- [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)
- [✨15. 三数之和](https://leetcode-cn.com/problems/3sum/)
- [26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)
- [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
- [✨283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

```javascript
let max = 0;
for (let i = 0, j = nums.length - 1; i !== j; ) {
    max = Math.max(max, Math.min(nums[i], nums[j]) * (j - i)) ;
    if (nums[i] < nums[j]) {
        i ++;
    } else {
        j --;
    }
}
return max;
```

### 双指针暴力
- [84. 柱状图中的最大矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

```javascript
var largestRectangleArea = function(heights) {
    if (!heights.length) return 0;
    let area = 0;
    for (let i = 0; i < heights.length; i ++) {
      let leftIndex = i;
      let rightIndex = i;
      let h = heights[i]; // 基准点，往前往后遍历求解
      while(heights[leftIndex - 1] >= h) {
        leftIndex --;
      }
      while(heights[rightIndex + 1] >= h) {
        rightIndex ++;
      }
      let distance = rightIndex - leftIndex + 1;
      area = Math.max(area, distance * h);
    }
    return area;
};


// let max = 0;
let leftMax = 0;
let rightMax = 0;
for (let i = 0, j = nums.length - 1; i !== j; ) {
    if (nums[i] < nums[j]) {
        if (leftMax < nums[i]) {
            leftMax = nums[i];
        } else {
            // some code ...
        }
        i ++;
    } else {
        if (rightMax < nums[j]) {
            rightMax = nums[j];
        } else {
            // some code ...
        }
        j --;
    }
}
```

## 递归
- [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```javascript
function recursion(level, param1, param2, ...) {
	// recursion terminator
	if (level > MAX_LEVEL) {
		procrss_result;
		return ;
	}
	
	// process logic in current level
	process(level, data ... );
	
	// drill down
	recursion(level + 1, new param1, new param2, ... );
	
	// reverse the current level status if needed
}
```


## 分治

```javascript 
function divideConquer(problem, param1, param2, ... ) {
	// recursion terminator
	if (!problem) {
		print_result;
		return ;
	}
	
	// prepare data
	data = prepareData(problem);
	subProblems = splitProblem(problem, data);
	
	// conquer subProblems
	subResult1 = divideConquer(subProblems[0], newParam1, new Param2, ... );
	subResult2 = divideConquer(subProblems[1], newParam1, new Param2, ... );
	subResult3 = divideConquer(subProblems[2], newParam1, new Param2, ... );
	...
	
	// process and generate the final result
	result = processResult(subResult1, subResult2, subResult3, ... );
	
	// revert the current level status
}
```


## [DFS + 回溯](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)
- [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)
- [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)
- [46. 全排列-i](https://leetcode-cn.com/problems/permutations/)
- [47. 全排列-ii](https://leetcode-cn.com/problems/permutations-ii/)
- [51. N皇后](https://leetcode-cn.com/problems/n-queens/)
- [77. 组合](https://leetcode-cn.com/problems/combinations/)


## 深度优先搜索

```javascript
function dfs(node) {
	if (node in visited) {
		// already visited
		return ;
	}
	
	visited.add(node);
	
	// process current node
	// ...
	// logic here
	
	dfs(node.left);
	dfs(node.right);
}
```

### DFS 代码 - 递归写法
```javascript
const visited = new Set;

function dfs(node, visited) {
	if (node in visited) {
		// already visited
		return ;
	}	
	
	visited.add(node);
	
	// process current  node here
	...
	for (nextNode in node.children) {
		if (!nextNode in visited) {
			dfs(nextNode, visited);
		}
	}
}

```

### DFS 代码 - 非递归写法

```javascript
function dfs(root) {
	if (!root) return [];
	const visited = new Set;
	const stack = [root];
	
	while (stack.length) {
		let node = stack.pop();
		visited.add(node);
		
		process(node);
		nodes = generateRelatedNodes(node);
		stack.push(nodes);
	}
	
	// other processing work
}
```


## BFS
- [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)
- [752. 打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/)

```javascript
function BFS(graph, start, end) {
	const queue = [];
	queue.push([start]);
	const visited = new Set;
	visited.add(start);
	
	while (queue.length) {
		let node = queue.shift();
		visited.add(node);
		
		process(node);
		nodes = generateRelatedNodes(node);
		queue.push(nodes);
	}
	
	// other processing work
}
```

## 二分查找
```javascript
let left = 0, right = arr.length - 1;

while (left < = right) {
	let mid = (left + right) / 2;
	if (arr[mid] === target) {
		// find the target
		break or return result;
	} else if (arr[mid] < target) {
		left = mid + 1;
	} else {
		right = mid - 1;
	}
}
```

## 组合
- [77. 组合](https://leetcode-cn.com/problems/combinations/)


```javascript
var combine = function (n, k) {
	let res = [];
	let start = 1, path = [];
	combineHelper(n, k, start, res, path);
	return res;
}
/**
 * 
 * @param {*} n 1 ... n 数组 1 ~ n
 * @param {*} k 取 k 个数
 * @param {*} start 从哪个开始取（不从数组下标0开始）
 * @param {*} res 结果集
 * @param {*} path 单个结果
 */
var combineHelper = function (n, k, start, res, path) {
	// recursion terminator
	if (path.length === k) {
		res.push(path.slice()); // 备份一份
	}
	
	// logic process
	for (let i = start; i <= n; i ++) { // 数组为 1 ～ n，所以终止条件 i <= n;（视情况而定）
		path.push(i); // 选
		// drill down
		combineHelper(n. k, i + 1, res, path);
		path.pop(); // 不选
	}
}
```

## 排列
- [46. 全排列-i](https://leetcode-cn.com/problems/permutations/)
- [47. 全排列-ii](https://leetcode-cn.com/problems/permutations-ii/)

```javascript
var permute = function(nums) {
	let res = [];
	let path =[];
	let usedNum = {};
	permuteHelper(nums, res, path, usedNum);
	return res;
};

/**
 * 
 * @param {*} nums 用于排列的数组
 * @param {*} res 结果集
 * @param {*} path 单个结果
 * @param {*} usedNum 使用过的数字
 */
 
 

var permuteHelper = function(nums, res, path, usedNum) {
	// recursion terminator
	if (path.length === nums.length) {
		res.push(path.slice());
	}
	
	// current level logic 
	for (let i = 0; i < nums.length; i ++) {
		if (usedNum[nums[i]] !== void 0) {
			continue;
		}
		path.push(nums[i]); // 选中
		usedNum[nums[i]] = truel;
		
		// drill down
		permuteHelper(nums, res, path, usedNum);
		
		path.pop(); // 未选中
		usedNum[nums[i]] = false; // 撤销使用记录
	}
};

```


```javascript

var permuteUnique = function(nums) {
  let res = [];
  let defaultNum = {};
  // 统计字符出现个数
  for (let i = 0; i < nums.length; i ++) {
    defaultNum[nums[i]] ? defaultNum[nums[i]] ++ : defaultNum[nums[i]] = 1;
  }
  let usedNum = {... defaultNum};
  nums = nums.sort();
  permuteUniqueHelper(nums, res, [], usedNum);
  return res;
};
/**
 * 
 * @param {*} nums 传入的可使用数组
 * @param {*} res 结果
 * @param {*} path 当前层结果
 * @param {*} usedNum 使用过的map
 */
var permuteUniqueHelper = function(nums, res, path, usedNum) {
  // recursion terminator
  if (path.length === nums.length) {
    res.push(path.slice());
    return ;
  }
  // current level logic
  for (let i = 0; i < nums.length; i ++) {
    if (nums[i - 1] == nums[i] && i - 1 >= 0 && usedNum[nums[i]]) { // 避免产生重复的排列
      continue;
    }
    if (usedNum[nums[i]] !== void 0 && usedNum[nums[i]] === 0) continue;
    usedNum[nums[i]] --; // 使用次数减一
    path.push(nums[i]);
    
    // drill down
    permuteUniqueHelper(nums, res, path, usedNum);
    
    path.pop();
    usedNum[nums[i]] ++; // 撤销使用记录 
  }
};
```

## 动态规划
- [✨300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
- [✨322 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

## 博弈论
- [292. Nim游戏](https://leetcode-cn.com/problems/nim-game/)
- [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)


## 写在后面