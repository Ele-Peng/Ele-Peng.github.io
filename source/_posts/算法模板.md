---
title: 算法模板
date: 2020-09-24 23:46:30
tags:
---



<style  type="text/css">
.lx-entry a {
    color: #191919;
    padding: 2px 0 1px 0;
    text-decoration: none;
    background-image: linear-gradient( transparent 0%, transparent calc(50% - 9px), rgba(247,65,65,.761) calc(50% - 9px), rgba(247,65,65,.761) 100% );
    transition: background-position 120ms ease-in-out, padding 120ms ease-in-out;
    background-size: 100% 200%;
    background-position: 0 0;
    word-break: break-word;
}

.lx-entry a:hover {
  background-image: linear-gradient( transparent 0%, transparent calc(50% - 9px), rgba(247,65,65,.761) calc(50% - 9px), rgba(247,65,65,.761) 100% );
  background-position: 0 100%;
}

.post-button a:hover {
  background-image: linear-gradient( transparent 0%, transparent calc(50% - 9px), transparent calc(50% - 9px), transparent 100% ) !important;
  background-position: 0 100% !important;
  outline: none !important;
  text-decoration: none !important;
}
</style>

## 写在前面
- 常见算法模板（自己总结，非官方）

<!-- more -->

## 单调栈
- [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
- [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)


```javascript
let stack = [];
let current = 0;
while(current < nums.length) {
    // 这是单调递增栈，视情况而定，当前元素是否大于栈顶元素
    while(stack.length && nums[current] < nums[stack[stack.length -1]]) {
        let base = nums[stack[stack.length -1]];
        stack.pop();
        if (!stack.length) break;
        // some code ...
    }
    stack.push(current);
    current ++;
}
```


## 双指针
- [1. 两数之和]()
- [11. 盛最多水的容器]()
- [15. 三数之和]()
- [42. 接雨水]()
- [84. 柱状图中的最大矩形]()
- [283. 移动零]()

```javascript
let max = 0;
for (let i = 0, j = nums.length - 1; i !== j; ) {
    max = Math.max(max, Math.min(nums[i], nums[j]) * (j - i)) ;
    if (nums[i] < nums[j]) {
        i ++;
    } else {
        j --;
    }
}
return max;
```

### 双指针暴力

```javascript
// let max = 0;
let leftMax = 0;
let rightMax = 0;
for (let i = 0, j = nums.length - 1; i !== j; ) {
    if (nums[i] < nums[j]) {
        if (leftMax < nums[i]) {
            leftMax = nums[i];
        } else {
            // some code ...
        }
        i ++;
    } else {
        if (rightMax < nums[j]) {
            rightMax = nums[j];
        } else {
            // some code ...
        }
        j --;
    }
}
```

## 递归

```javascript
function recursion(level, param1, param2, ...) {
	// recursion terminator
	if (level > MAX_LEVEL) {
		procrss_result;
		return ;
	}
	
	// process logic in current level
	process(level, data ... );
	
	// drill down
	recursion(level + 1, new param1, new param2, ... );
	
	// reverse the current level status if needed
}
```


## 分治

```javascript 
function divideConquer(problem, param1, param2, ... ) {
	// recursion terminator
	if (!problem) {
		print_result;
		return ;
	}
	
	// prepare data
	data = prepareData(problem);
	subProblems = splitProblem(problem, data);
	
	// conquer subProblems
	subResult1 = divideConquer(subProblems[0], newParam1, new Param2, ... );
	subResult2 = divideConquer(subProblems[1], newParam1, new Param2, ... );
	subResult3 = divideConquer(subProblems[2], newParam1, new Param2, ... );
	...
	
	// process and generate the final result
	result = processResult(subResult1, subResult2, subResult3, ... );
	
	// revert the current level status
}
```


## 回溯


## 深度优先搜索

```javascript
function dfs(node) {
	if (node in visited) {
		// already visited
		return ;
	}
	
	visited.add(node);
	
	// process current node
	// ...
	// logic here
	
	dfs(node.left);
	dfs(node.right);
}
```

### DFS 代码 - 递归写法
```javascript
const visited = new Set;

function dfs(node, visited) {
	if (node in visited) {
		// already visited
		return ;
	}	
	
	visited.add(node);
	
	// process current  node here
	...
	for (nextNode in node.children) {
		if (!nextNode in visited) {
			dfs(nextNode, visited);
		}
	}
}

```

### DFS 代码 - 非递归写法

```javascript
function dfs(root) {
	if (!root) return [];
	const visited = new Set;
	const stack = [root];
	
	while (stack.length) {
		let node = stack.pop();
		visited.add(node);
		
		process(node);
		nodes = generateRelatedNodes(node);
		stack.push(nodes);
	}
	
	// other processing work
}
```


## BFS

```javascript
function BFS(graph, start, end) {
	const queue = [];
	queue.push([start]);
	const visited = new Set;
	visited.add(start);
	
	while (queue.length) {
		let node = queue.shift();
		visited.add(node);
		
		process(node);
		nodes = generateRelatedNodes(node);
		queue.push(nodes);
	}
	
	// other processing work
}
```

## 二分查找
```javascript
let left = 0, right = arr.length - 1;

while (left < = right) {
	let mid = (left + right) / 2;
	if (arr[mid] === target) {
		// find the target
		break or return result;
	} else if (arr[mid] < target) {
		left = mid + 1;
	} else {
		right = mid - 1;
	}
}
```

## 组合
```javascript
var combine = function (n, k) {
	let res = [];
	let start = 1, path = [];
	combineHelper(n, k, start, res, path);
	return res;
}
/**
 * 
 * @param {*} n 1 ... n 数组 1 ~ n
 * @param {*} k 取 k 个数
 * @param {*} start 从哪个开始取（不从数组下标0开始）
 * @param {*} res 结果集
 * @param {*} path 单个结果
 */
var combineHelper = function (n, k, start, res, path) {
	// recursion terminator
	if (path.length === k) {
		res.push(path.slice()); // 备份一份
	}
	
	// logic process
	for (let i = start; i <= n; i ++) { // 数组为 1 ～ n，所以终止条件 i <= n;（视情况而定）
		path.push(i); // 选
		// drill down
		combineHelper(n. k, i + 1, res, path);
		path.pop(); // 不选
	}
}
```

## 排列

```javascript
var permute = function(nums) {
	let res = [];
	let path =[];
	let usedNum = {};
	permuteHelper(nums, res, path, usedNum);
	return res;
};

/**
 * 
 * @param {*} nums 用于排列的数组
 * @param {*} res 结果集
 * @param {*} path 单个结果
 * @param {*} usedNum 使用过的数字
 */
 
 

var permuteHelper = function(nums, res, path, usedNum) {
	// recursion terminator
	if (path.length === nums.length) {
		res.push(path.slice());
	}
	
	// current level logic 
	for (let i = 0; i < nums.length; i ++) {
		if (usedNum[nums[i]] !== void 0) {
			continue;
		}
		path.push(nums[i]); // 选中
		usedNum[nums[i]] = truel;
		
		// drill down
		permuteHelper(nums, res, path, usedNum);
		
		path.pop(); // 未选中
		usedNum[nums[i]] = false; // 撤销使用记录
	}
};

```


```javascript

var permuteUnique = function(nums) {
  let res = [];
  let defaultNum = {};
  // 统计字符出现个数
  for (let i = 0; i < nums.length; i ++) {
    defaultNum[nums[i]] ? defaultNum[nums[i]] ++ : defaultNum[nums[i]] = 1;
  }
  let usedNum = {... defaultNum};
  nums = nums.sort();
  permuteUniqueHelper(nums, res, [], usedNum);
  return res;
};
/**
 * 
 * @param {*} nums 传入的可使用数组
 * @param {*} res 结果
 * @param {*} path 当前层结果
 * @param {*} usedNum 使用过的map
 */
var permuteUniqueHelper = function(nums, res, path, usedNum) {
  // recursion terminator
  if (path.length === nums.length) {
    res.push(path.slice());
    return ;
  }
  // current level logic
  for (let i = 0; i < nums.length; i ++) {
    if (nums[i - 1] == nums[i] && i - 1 >= 0 && usedNum[nums[i]]) { // 避免产生重复的排列
      continue;
    }
    if (usedNum[nums[i]] !== void 0 && usedNum[nums[i]] === 0) continue;
    usedNum[nums[i]] --; // 使用次数减一
    path.push(nums[i]);
    
    // drill down
    permuteUniqueHelper(nums, res, path, usedNum);
    
    path.pop();
    usedNum[nums[i]] ++; // 撤销使用记录 
  }
};
```

## 写在后面